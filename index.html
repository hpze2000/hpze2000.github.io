<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>




  <meta name="keywords" content="johnson,njiandan.com" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Johnson Zhang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Johnson Zhang">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Johnson Zhang">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Johnson Zhang </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?886f45b065a917294e24691553891b06";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Johnson Zhang</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            關於
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            標籤
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            <i class="menu-item-icon icon-next-commonweal"></i> <br />
            公益404
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/08/node-process/" itemprop="url">
                Node.js 之 进程管理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-08T14:45:20+08:00" content="2016-01-08">
            2016-01-08
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/javascript/" itemprop="url" rel="index">
                  <span itemprop="name">javascript</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/08/node-process/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/08/node-process/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>我们已经知道了NodeJS自带的<code>fs</code>模块比较基础，把一个目录里的所有文件和子目录都拷贝到另一个目录里需要写不少代码。另外我们也知道，终端下的<code>cp</code>命令比较好用，一条<code>cp -r source/* target</code>命令就能搞定目录拷贝。那我们首先看看如何使用NodeJS调用终端命令来简化目录拷贝，示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">source, target, callback</span>) </span>&#123;</span><br><span class="line">    child_process.exec(</span><br><span class="line">        util.format(<span class="string">'cp -r %s/* %s'</span>, source, target), callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从以上代码中可以看到，子进程是异步运行的，通过回调函数返回执行结果。</p>
<h1 id="API_介绍">API 介绍</h1><p>我们先大致看看NodeJS提供了哪些和进程管理有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h2 id="Process">Process</h2><p><code>官方文档： http://nodejs.org/api/process.html</code><br>任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJS中，可以通过<code>process</code>对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，<code>process</code>不是内置模块，而是一个<code>全局对象</code>，因此在任何地方都可以直接使用。</p>
<h2 id="Child_Process">Child Process</h2><p><code>官方文档： http://nodejs.org/api/child_process.html</code><br>使用<code>child_process</code>模块可以创建和控制子进程。该模块提供的API中最核心的是<code>.spawn</code>，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。</p>
<h2 id="Cluster">Cluster</h2><p><code>官方文档： http://nodejs.org/api/cluster.html</code><br><code>cluster</code>模块是对<code>child_process</code>模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。</p>
<h1 id="应用场景">应用场景</h1><h2 id="如何获取命令行参数">如何获取命令行参数</h2><p>在NodeJS中可以通过<code>process.argv</code>获取命令行参数。但是比较意外的是，<code>node</code>执行程序路径和主模块文件路径固定占据了<code>argv[0]</code>和<code>argv[1]</code>两个位置，而第一个命令行参数从<code>argv[2]</code>开始。为了让<code>argv</code>使用起来更加自然，可以按照以下方式处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<h2 id="如何退出程序">如何退出程序</h2><p>通常一个程序做完所有事情后就正常退出了，这时程序的退出状态码为<code>0</code>。或者一个程序运行时发生了异常后就挂了，这时程序的退出状态码不等于0。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字，比如<code>1</code>，就可以按照以下方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="如何控制输入输出">如何控制输入输出</h2><p>NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应<code>process.stdin</code>、<code>process.stdout</code>和<code>process.stderr</code>，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。例如，<code>console.log</code>可以按照以下方式实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    process.stdout.write(util.format.apply(util, <span class="built_in">arguments</span>) + <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="如何降权">如何降权</h2><p>在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。以下是这样一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(callback).listen(<span class="number">80</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> env = process.env,</span><br><span class="line">        uid = <span class="built_in">parseInt</span>(env[<span class="string">'SUDO_UID'</span>] || process.getuid(), <span class="number">10</span>),</span><br><span class="line">        gid = <span class="built_in">parseInt</span>(env[<span class="string">'SUDO_GID'</span>] || process.getgid(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    process.setgid(gid);</span><br><span class="line">    process.setuid(uid);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上例中有几点需要注意：</p>
<ol>
<li>如果是通过sudo获取root权限的，运行程序的用户的UID和GID保存在环境变量SUDO_UID和SUDO_GID里边。如果是通过<code>chmod +s</code>方式获取<code>root</code>权限的，运行程序的用户的UID和GID可直接通过<code>process.getuid</code>和<code>process.getgid</code>方法获取。</li>
<li><code>process.setuid</code>和<code>process.setgid</code>方法只接受number类型的参数。</li>
<li>降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。</li>
</ol>
<h2 id="如何创建子进程">如何创建子进程</h2><p>以下是一个创建NodeJS子进程的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = child_process.spawn(<span class="string">'node'</span>, [ <span class="string">'xxx.js'</span> ]);</span><br><span class="line"></span><br><span class="line">child.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stderr: '</span> + data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child process exited with code '</span> + code);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上例中使用了<code>.spawn(exec, args, options)</code>方法，该方法支持三个参数。第一个参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。</p>
<p>另外，上例中虽然通过子进程对象的<code>.stdout</code>和<code>.stderr</code>访问子进程的输出，但通过<code>options.stdio</code>字段的不同配置，可以将子进程的输入输出重定向到任何数据流上，或者让子进程共享父进程的标准输入输出流，或者直接忽略子进程的输入输出。</p>
<h2 id="进程间如何通讯">进程间如何通讯</h2><p>在Linux系统下，进程之间可以通过信号互相通信。以下是一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* parent.js */</span></span><br><span class="line"><span class="keyword">var</span> child = child_process.spawn(<span class="string">'node'</span>, [ <span class="string">'child.js'</span> ]);</span><br><span class="line"></span><br><span class="line">child.kill(<span class="string">'SIGTERM'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* child.js */</span></span><br><span class="line">process.on(<span class="string">'SIGTERM'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cleanUp();</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上例中，父进程通过<code>.kill</code>方法向子进程发送<code>SIGTERM</code>信号，子进程监听<code>process</code>对象的<code>SIGTERM</code>事件响应信号。不要被<code>.kill</code>方法的名称迷惑了，该方法本质上是用来给进程发送信号的，进程收到信号后具体要做啥，完全取决于信号的种类和进程自身的代码。</p>
<p>另外，如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。以下是一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* parent.js */</span></span><br><span class="line"><span class="keyword">var</span> child = child_process.spawn(<span class="string">'node'</span>, [ <span class="string">'child.js'</span> ], &#123;</span><br><span class="line">        stdio: [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'ipc'</span> ]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">child.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.send(&#123; hello: <span class="string">'hello'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* child.js */</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    msg.hello = msg.hello.toUpperCase();</span><br><span class="line">    process.send(msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，父进程在创建子进程时，在<code>options.stdio</code>字段中通过<code>ipc</code>开启了一条IPC通道，之后就可以监听子进程对象的<code>message</code>事件接收来自子进程的消息，并通过<code>.send</code>方法给子进程发送消息。在子进程这边，可以在<code>process</code>对象上监听<code>message</code>事件接收来自父进程的消息，并通过<code>.send</code>方法向父进程发送消息。数据在传递过程中，会先在发送端使用<code>JSON.stringify</code>方法序列化，再在接收端使用<code>JSON.parse</code>方法反序列化。</p>
<h2 id="如何守护子进程">如何守护子进程</h2><p>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。以下是一种实现方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* daemon.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">mainModule</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> worker = child_process.spawn(<span class="string">'node'</span>, [ mainModule ]);</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</span><br><span class="line">            spawn(mainModule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn(<span class="string">'worker.js'</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，工作进程非正常退出时，守护进程立即重启工作进程。</p>
<h1 id="小结">小结</h1><ul>
<li>使用<code>process</code>对象管理自身。</li>
<li>使用<code>child_process</code>模块创建和管理子进程。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/08/node-network/" itemprop="url">
                Node.js 之 网络操作
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-08T11:45:20+08:00" content="2016-01-08">
            2016-01-08
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/javascript/" itemprop="url" rel="index">
                  <span itemprop="name">javascript</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/08/node-network/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/08/node-network/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>NodeJS本来的用途是编写高性能Web服务器。我们首先在这里重复一下官方文档里的例子，使用NodeJS内置的http模块简单实现一个HTTP服务器。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text-plain'</span> &#125;);</span><br><span class="line">    response.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8124</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上程序创建了一个HTTP服务器并监听8124端口，打开浏览器访问该端口<code>http://127.0.0.1:8124/</code>就能够看到效果。</p>
<blockquote>
<p>在Linux系统下，监听1024以下端口需要root权限。因此，如果想监听80或443端口的话，需要使用sudo命令启动程序。</p>
</blockquote>
<h1 id="API_介绍">API 介绍</h1><p>我们先大致看看NodeJS提供了哪些和网络操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h2 id="HTTP">HTTP</h2><p><code>官方文档： http://nodejs.org/api/http.html</code></p>
<p><code>http</code>模块提供两种使用方式：</p>
<ol>
<li>作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。</li>
<li>作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。</li>
</ol>
<p>首先我们来看看服务端模式下如何工作。如开门红中的例子所示，首先需要使用<code>.createServer</code>方法创建一个服务器，然后调用<code>.listen</code>方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。可以看出，这是一种事件机制。</p>
<p>HTTP请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。例如以下是一个完整的HTTP请求数据内容。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">POST <span class="string">/</span> HTTP/1.1</span></span><br><span class="line"><span class="attribute">User-Agent</span>: <span class="string">curl/7.26.0</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="string">localhost</span></span><br><span class="line"><span class="attribute">Accept</span>: <span class="string">*/*</span></span><br><span class="line"><span class="attribute">Content-Length</span>: <span class="string">11</span></span><br><span class="line"><span class="attribute">Content-Type</span>: <span class="string">application/x-www-form-urlencoded</span></span><br><span class="line"></span><br><span class="line"><span class="nginx"><span class="title">Hello</span> World</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，空行之上是请求头，之下是请求体。HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而http模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。在回调函数中，除了可以使用<code>request</code>对象访问请求头数据外，还能把<code>request</code>对象当作一个只读数据流来访问请求体数据。以下是一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body = [];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(request.method);</span><br><span class="line">    <span class="built_in">console</span>.log(request.headers);</span><br><span class="line"></span><br><span class="line">    request.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        body.push(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    request.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        body = Buffer.concat(body);</span><br><span class="line">        <span class="built_in">console</span>.log(body.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">POST</span><br><span class="line">&#123; <span class="string">'user-agent'</span>: <span class="string">'curl/7.26.0'</span>,</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  accept: <span class="string">'*/*'</span>,</span><br><span class="line">  <span class="string">'content-length'</span>: <span class="string">'11'</span>,</span><br><span class="line">  <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p>
<p>HTTP响应本质上也是一个数据流，同样由响应头（headers）和响应体（body）组成。例如以下是一个完整的HTTP请求数据内容。<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="status">HTTP/1.1 <span class="number">200</span> OK</span></span><br><span class="line"><span class="attribute">Content-Type</span>: <span class="string">text/plain</span></span><br><span class="line"><span class="attribute">Content-Length</span>: <span class="string">11</span></span><br><span class="line"><span class="attribute">Date</span>: <span class="string">Tue, 05 Nov 2013 05:31:38 GMT</span></span><br><span class="line"><span class="attribute">Connection</span>: <span class="string">keep-alive</span></span><br><span class="line"></span><br><span class="line"><span class="nginx"><span class="title">Hello</span> World</span></span><br></pre></td></tr></table></figure></p>
<p>在回调函数中，除了可以使用<code>response</code>对象来写入响应头数据外，还能把<code>response</code>对象当作一个只写数据流来写入响应体数据。例如在以下例子中，服务端原样将客户端请求的请求体数据返回给客户端。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line"></span><br><span class="line">    request.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        response.write(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    request.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        response.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>接下来我们看看客户端模式下如何工作。为了发起一个客户端HTTP请求，我们需要指定目标服务器的位置并发送请求头和请求体，以下示例演示了具体做法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">        hostname: <span class="string">'www.example.com'</span>,</span><br><span class="line">        port: <span class="number">80</span>,</span><br><span class="line">        path: <span class="string">'/upload'</span>,</span><br><span class="line">        method: <span class="string">'POST'</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = http.request(options, <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">request.write(<span class="string">'Hello World'</span>);</span><br><span class="line">request.end();</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>.request</code>方法创建了一个客户端，并指定请求目标和请求头数据。之后，就可以把<code>request</code>对象当作一个只写数据流来写入请求体数据和结束请求。另外，由于HTTP请求中<code>GET</code>请求是最常见的一种，并且不需要请求体，因此<code>http</code>模块也提供了以下便捷API：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.get(<span class="string">'http://www.example.com/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数。在回调函数中，除了可以使用<code>response</code>对象访问响应头数据外，还能把<code>response</code>对象当作一个只读数据流来访问响应体数据。以下是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http.get(<span class="string">'http://www.example.com/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body = [];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(response.statusCode);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line"></span><br><span class="line">    response.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        body.push(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    response.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        body = Buffer.concat(body);</span><br><span class="line">        <span class="built_in">console</span>.log(body.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line"><span class="number">200</span></span><br><span class="line">&#123; <span class="string">'content-type'</span>: <span class="string">'text/html'</span>,</span><br><span class="line">  server: <span class="string">'Apache'</span>,</span><br><span class="line">  <span class="string">'content-length'</span>: <span class="string">'801'</span>,</span><br><span class="line">  date: <span class="string">'Tue, 05 Nov 2013 06:08:41 GMT'</span>,</span><br><span class="line">  connection: <span class="string">'keep-alive'</span> &#125;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTPS">HTTPS</h2><p><code>官方文档： http://nodejs.org/api/https.html</code><br><code>https</code>模块与<code>http</code>模块极为类似，区别在于<code>https</code>模块需要额外处理<code>SSL证书</code>。</p>
<p>在服务端模式下，创建一个HTTPS服务器的示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">        key: fs.readFileSync(<span class="string">'./ssl/default.key'</span>),</span><br><span class="line">        cert: fs.readFileSync(<span class="string">'./ssl/default.cer'</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = https.createServer(options, <span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，与创建HTTP服务器相比，多了一个<code>options</code>对象，通过<code>key</code>和<code>cert</code>字段指定了HTTPS服务器使用的私钥和公钥。<br>另外，NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。接着上例，可以使用以下方法为HTTPS服务器添加多组证书。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server.addContext(<span class="string">'foo.com'</span>, &#123;</span><br><span class="line">    key: fs.readFileSync(<span class="string">'./ssl/foo.com.key'</span>),</span><br><span class="line">    cert: fs.readFileSync(<span class="string">'./ssl/foo.com.cer'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.addContext(<span class="string">'bar.com'</span>, &#123;</span><br><span class="line">    key: fs.readFileSync(<span class="string">'./ssl/bar.com.key'</span>),</span><br><span class="line">    cert: fs.readFileSync(<span class="string">'./ssl/bar.com.cer'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在客户端模式下，发起一个HTTPS客户端请求与http模块几乎相同，示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">        hostname: <span class="string">'www.example.com'</span>,</span><br><span class="line">        port: <span class="number">443</span>,</span><br><span class="line">        path: <span class="string">'/'</span>,</span><br><span class="line">        method: <span class="string">'GET'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = https.request(options, <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">request.end();</span><br></pre></td></tr></table></figure></p>
<p>但如果目标服务器使用的SSL证书是自制的，不是从颁发机构购买的，默认情况下<code>https</code>模块会拒绝连接，提示说有证书安全问题。在<code>options</code>里加入<code>rejectUnauthorized: false</code>字段可以禁用对证书有效性的检查，从而允许<code>https</code>模块请求开发环境下使用自制证书的HTTPS服务器。</p>
<h2 id="URL">URL</h2><p><code>官方文档： http://nodejs.org/api/url.html</code><br>处理HTTP请求时<code>url</code>模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。首先我们来看看一个完整的URL的各组成部分：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                           <span class="comment">href</span></span><br><span class="line"> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">                            <span class="comment">host</span>              <span class="comment">path</span></span><br><span class="line">                      <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"> <span class="comment">http:</span> <span class="comment">//</span> <span class="comment">user:pass</span> <span class="comment">@</span> <span class="comment">host</span><span class="string">.</span><span class="comment">com</span> <span class="comment">:</span> <span class="comment">8080</span> <span class="comment">/p/a/t/h</span> <span class="comment">?query=string</span> <span class="comment">#hash</span></span><br><span class="line"> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>    <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>   <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>   <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"><span class="comment">protocol</span>     <span class="comment">auth</span>     <span class="comment">hostname</span>   <span class="comment">port</span> <span class="comment">pathname</span>     <span class="comment">search</span>     <span class="comment">hash</span></span><br><span class="line">                                                <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line">                                                   <span class="comment">query</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以使用<code>.parse</code>方法来将一个URL字符串转换为URL对象，示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">url.parse(<span class="string">'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</span>);</span><br><span class="line"><span class="comment">/* =&gt;</span><br><span class="line">&#123; protocol: 'http:',</span><br><span class="line">  auth: 'user:pass',</span><br><span class="line">  host: 'host.com:8080',</span><br><span class="line">  port: '8080',</span><br><span class="line">  hostname: 'host.com',</span><br><span class="line">  hash: '#hash',</span><br><span class="line">  search: '?query=string',</span><br><span class="line">  query: 'query=string',</span><br><span class="line">  pathname: '/p/a/t/h',</span><br><span class="line">  path: '/p/a/t/h?query=string',</span><br><span class="line">  href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash' &#125;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>传给<code>.parse</code>方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，<code>request.url</code>不包含协议头和域名，但同样可以用<code>.parse</code>方法解析。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = request.url; <span class="comment">// =&gt; "/foo/bar?a=b"</span></span><br><span class="line">    url.parse(tmp);</span><br><span class="line">    <span class="comment">/* =&gt;</span><br><span class="line">    &#123; protocol: null,</span><br><span class="line">      slashes: null,</span><br><span class="line">      auth: null,</span><br><span class="line">      host: null,</span><br><span class="line">      port: null,</span><br><span class="line">      hostname: null,</span><br><span class="line">      hash: null,</span><br><span class="line">      search: '?a=b',</span><br><span class="line">      query: 'a=b',</span><br><span class="line">      pathname: '/foo/bar',</span><br><span class="line">      path: '/foo/bar?a=b',</span><br><span class="line">      href: '/foo/bar?a=b' &#125;</span><br><span class="line">    */</span></span><br><span class="line">&#125;).listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>.parse</code>方法还支持第二个和第三个布尔类型可选参数。第二个参数等于true时，该方法返回的URL对象中，<code>query</code>字段不再是一个字符串，而是一个经过<code>querystring</code>模块转换后的参数对象。第三个参数等于true时，该方法可以正确解析不带协议头的URL，例如<code>//www.example.com/foo/bar</code>。<br>反过来，<code>format</code>方法允许将一个URL对象转换为URL字符串，示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url.format(&#123;</span><br><span class="line">    protocol: <span class="string">'http:'</span>,</span><br><span class="line">    host: <span class="string">'www.example.com'</span>,</span><br><span class="line">    pathname: <span class="string">'/p/a/t/h'</span>,</span><br><span class="line">    search: <span class="string">'query=string'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* =&gt;</span><br><span class="line">'http://www.example.com/p/a/t/h?query=string'</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>另外，<code>.resolve</code>方法可以用于拼接URL，示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url.resolve(<span class="string">'http://www.example.com/foo/bar'</span>, <span class="string">'../baz'</span>);</span><br><span class="line"><span class="comment">/* =&gt;</span><br><span class="line">http://www.example.com/baz</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Query_String">Query String</h2><p><code>官方文档： http://nodejs.org/api/querystring.html</code><br><code>querystring</code>模块用于实现URL参数字符串与参数对象的互相转换，示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">querystring.parse(<span class="string">'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge'</span>);</span><br><span class="line"><span class="comment">/* =&gt;</span><br><span class="line">&#123; foo: 'bar', baz: ['qux', 'quux'], corge: '' &#125;</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">querystring.stringify(&#123; foo: <span class="string">'bar'</span>, baz: [<span class="string">'qux'</span>, <span class="string">'quux'</span>], corge: <span class="string">''</span> &#125;);</span><br><span class="line"><span class="comment">/* =&gt;</span><br><span class="line">'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge='</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Zlib">Zlib</h2><p><code>官方文档： http://nodejs.org/api/zlib.html</code><br><code>zlib</code>模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。</p>
<p>首先我们看一个使用<code>zlib</code>模块压缩HTTP响应体数据的例子。这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用zlib模块返回gzip之后的响应体数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1024</span>,</span><br><span class="line">        data = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        data += <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((request.headers[<span class="string">'accept-encoding'</span>] || <span class="string">''</span>).indexOf(<span class="string">'gzip'</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">        zlib.gzip(data, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">            response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">                <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>,</span><br><span class="line">                <span class="string">'Content-Encoding'</span>: <span class="string">'gzip'</span></span><br><span class="line">            &#125;);</span><br><span class="line">            response.end(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">        &#125;);</span><br><span class="line">        response.end(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>接着我们看一个使用<code>zlib</code>模块解压HTTP响应体数据的例子。这个例子中，判断了服务端响应是否使用<code>gzip</code>压缩，并在压缩的情况下使用zlib模块解压响应体数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">        hostname: <span class="string">'www.example.com'</span>,</span><br><span class="line">        port: <span class="number">80</span>,</span><br><span class="line">        path: <span class="string">'/'</span>,</span><br><span class="line">        method: <span class="string">'GET'</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">http.request(options, <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body = [];</span><br><span class="line"></span><br><span class="line">    response.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        body.push(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    response.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        body = Buffer.concat(body);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response.headers[<span class="string">'content-encoding'</span>] === <span class="string">'gzip'</span>) &#123;</span><br><span class="line">            zlib.gunzip(body, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).end();</span><br></pre></td></tr></table></figure></p>
<h2 id="Net">Net</h2><p><code>官方文档： http://nodejs.org/api/net.html</code><br><code>net</code>模块可用于创建Socket服务器或Socket客户端。由于Socket在前端领域的使用范围还不是很广，这里先不涉及到WebSocket的介绍，仅仅简单演示一下如何从Socket层面来实现HTTP请求和响应。</p>
<p>首先我们来看一个使用Socket搭建一个很不严谨的HTTP服务器的例子。这个HTTP服务器不管收到啥请求，都固定返回相同的响应：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">conn</span>) </span>&#123;</span><br><span class="line">    conn.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        conn.write([</span><br><span class="line">            <span class="string">'HTTP/1.1 200 OK'</span>,</span><br><span class="line">            <span class="string">'Content-Type: text/plain'</span>,</span><br><span class="line">            <span class="string">'Content-Length: 11'</span>,</span><br><span class="line">            <span class="string">''</span>,</span><br><span class="line">            <span class="string">'Hello World'</span></span><br><span class="line">        ].join(<span class="string">'\n'</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">80</span>);</span><br></pre></td></tr></table></figure></p>
<p>接着我们来看一个使用Socket发起HTTP客户端请求的例子。这个例子中，Socket客户端在建立连接后发送了一个HTTP GET请求，并通过data事件监听函数来获取服务器响应：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">        port: <span class="number">80</span>,</span><br><span class="line">        host: <span class="string">'www.example.com'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = net.connect(options, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        client.write([</span><br><span class="line">            <span class="string">'GET / HTTP/1.1'</span>,</span><br><span class="line">            <span class="string">'User-Agent: curl/7.26.0'</span>,</span><br><span class="line">            <span class="string">'Host: www.baidu.com'</span>,</span><br><span class="line">            <span class="string">'Accept: */*'</span>,</span><br><span class="line">            <span class="string">''</span>,</span><br><span class="line">            <span class="string">''</span></span><br><span class="line">        ].join(<span class="string">'\n'</span>));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    client.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="小结">小结</h1><ul>
<li>http和https模块支持服务端模式和客户端模式两种使用方式。</li>
<li>request和response对象除了用于读写头数据外，都可以当作数据流来操作。</li>
<li>url.parse方法加上request.url属性是处理HTTP请求时的固定搭配。</li>
<li>使用zlib模块可以减少使用HTTP协议时的数据传输量。</li>
<li>通过net模块的Socket服务器与客户端可对HTTP协议做底层操作。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/07/nodejs-fs/" itemprop="url">
                Node.js 之 文件操作
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-07T10:37:20+08:00" content="2016-01-07">
            2016-01-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/javascript/" itemprop="url" rel="index">
                  <span itemprop="name">javascript</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/07/nodejs-fs/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/07/nodejs-fs/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="了解文件操作">了解文件操作</h1><p>NodeJS提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与<code>copy</code>命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。</p>
<h2 id="小文件拷贝">小文件拷贝</h2><p>我们使用NodeJS内置的<code>fs</code>模块简单实现这个程序如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dst</span>) </span>&#123;</span><br><span class="line">    fs.writeFileSync(dst, fs.readFileSync(src));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>) </span>&#123;</span><br><span class="line">    copy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>以上程序使用<code>fs.readFileSync</code>从源路径读取文件内容，并使用<code>fs.writeFileSync</code>将文件内容写入目标路径。</p>
<blockquote>
<p><code>process</code>是一个全局变量，可通过<code>process.argv</code>获得命令行参数。由于<code>argv[0]</code>固定等于NodeJS执行程序的绝对路径，<code>argv[1]</code>固定等于主模块的绝对路径，因此第一个命令行参数从<code>argv[2]</code>这个位置开始。</p>
</blockquote>
<h2 id="大文件拷贝">大文件拷贝</h2><p>上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dst</span>) </span>&#123;</span><br><span class="line">    fs.createReadStream(src).pipe(fs.createWriteStream(dst));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">argv</span>) </span>&#123;</span><br><span class="line">    copy(argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(process.argv.slice(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>以上程序使用<code>fs.createReadStream</code>创建了一个源文件的只读数据流，并使用<code>fs.createWriteStream</code>创建了一个目标文件的只写数据流，并且用<code>pipe</code>方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。</p>
<h1 id="API介绍">API介绍</h1><p>我们先大致看看NodeJS提供了哪些和文件操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h2 id="Buffer（数据块）">Buffer（数据块）</h2><p><code>官方文档： http://nodejs.org/api/buffer.html</code><br>JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与<code>String</code>对等的全局构造函数<code>Buffer</code>来提供对二进制数据的操作。除了可以读取文件得到<code>Buffer</code>的实例外，还能够直接构造，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer([ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]);</span><br></pre></td></tr></table></figure></p>
<p><code>Buffer</code>与字符串类似，除了可以用<code>.length</code>属性得到字节长度外，还可以用<code>[index]</code>方式读取指定位置的字节，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin[<span class="number">0</span>]; <span class="comment">// =&gt; 0x68;</span></span><br></pre></td></tr></table></figure></p>
<p><code>Buffer</code>与<code>字符串</code>能够互相转化，例如可以使用指定编码将二进制数据转化为字符串：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = bin.toString(<span class="string">'utf-8'</span>); <span class="comment">// =&gt; "hello"</span></span><br></pre></td></tr></table></figure></p>
<p>或者反过来，将字符串转换为指定编码下的二进制数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer(<span class="string">'hello'</span>, <span class="string">'utf-8'</span>); <span class="comment">// =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>Buffer</code>与<code>字符串</code>有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于<code>Buffer</code>，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin[<span class="number">0</span>] = <span class="number">0x48</span>;</span><br></pre></td></tr></table></figure></p>
<p>而<code>.slice</code>方法也不是返回一个新的<code>Buffer</code>，而更像是返回了指向原<code>Buffer</code>中间的某个位置的指针，如下所示。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]</span><br><span class="line">    ^           ^</span><br><span class="line">    |           |</span><br><span class="line">   bin     bin.slice(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>因此对<code>.slice</code>方法返回的<code>Buffer</code>的修改会作用于原<code>Buffer</code>，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer([ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]);</span><br><span class="line"><span class="keyword">var</span> sub = bin.slice(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">sub[<span class="number">0</span>] = <span class="number">0x65</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bin); <span class="comment">// =&gt; &lt;Buffer 68 65 65 6c 6f&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>也因此，如果想要拷贝一份<code>Buffer</code>，得首先创建一个新的<code>Buffer</code>，并通过.<code>copy</code>方法把原<code>Buffer</code>中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="keyword">new</span> Buffer([ <span class="number">0x68</span>, <span class="number">0x65</span>, <span class="number">0x6c</span>, <span class="number">0x6c</span>, <span class="number">0x6f</span> ]);</span><br><span class="line"><span class="keyword">var</span> dup = <span class="keyword">new</span> Buffer(bin.length);</span><br><span class="line"></span><br><span class="line">bin.copy(dup);</span><br><span class="line">dup[<span class="number">0</span>] = <span class="number">0x48</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bin); <span class="comment">// =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(dup); <span class="comment">// =&gt; &lt;Buffer 48 65 65 6c 6f&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>总之，<code>Buffer</code>将JS的数据处理能力从<code>字符串</code>扩展到了任意二进制数据。</p>
<h2 id="Stream（数据流）">Stream（数据流）</h2><p><code>官方文档： http://nodejs.org/api/stream.html</code></p>
<p>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种<code>Stream</code>来提供对数据流的操作。</p>
<p>以上边的大文件拷贝程序为例，我们可以为数据来源创建一个只读数据流，示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(pathname);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    doSomething(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cleanUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>Stream</code>基于事件机制工作，所有<code>Stream</code>的实例都继承于NodeJS提供的<code>EventEmitter</code>。</p>
</blockquote>
<p>上边的代码中<code>data</code>事件会源源不断地被触发，不管<code>doSomething</code>函数是否处理得过来。代码可以继续做如下改造，以解决这个问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(src);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    rs.pause();</span><br><span class="line">    doSomething(chunk, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        rs.resume();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cleanUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上代码给<code>doSomething</code>函数加上了<code>回调</code>，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。</p>
<p>此外，我们也可以为数据目标创建一个只写数据流，示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(src);</span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(dst);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    ws.write(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ws.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们把<code>doSomething</code>换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据<code>.write</code>方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据<code>drain</code>事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。因此代码可以改造如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(src);</span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(dst);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.write(chunk) === <span class="literal">false</span>) &#123;</span><br><span class="line">        rs.pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ws.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    rs.resume();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上代码实现了数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。因为这种使用场景很多，例如上边的大文件拷贝程序，NodeJS直接提供了<code>.pipe</code>方法来做这件事情，其内部实现方式与上边的代码类似。</p>
<h2 id="File_System（文件系统）">File System（文件系统）</h2><p><code>官方文档： http://nodejs.org/api/fs.html</code><br>NodeJS通过fs内置模块提供对文件的操作。<code>fs</code>模块提供的API基本上可以分为以下三类：</p>
<ul>
<li>文件属性读写。<br>  其中常用的有<code>fs.stat</code>、<code>fs.chmod</code>、<code>fs.chown</code>等等。</li>
<li>文件内容读写。<br>  其中常用的有<code>fs.readFile</code>、<code>fs.readdir</code>、<code>fs.writeFile</code>、<code>fs.mkdir</code>等等。</li>
<li>底层文件操作。<br>  其中常用的有<code>fs.open</code>、<code>fs.read</code>、<code>fs.write</code>、<code>fs.close</code>等等。    </li>
</ul>
<p>NodeJS最精华的<code>异步IO模型</code>在<code>fs</code>模块里有着充分的体现，例如上边提到的这些API都通过回调函数传递结果。以<code>fs.readFile</code>为例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(pathname, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// Deal with error.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Deal with data.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如上边代码所示，基本上所有<code>fs</code>模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果。<br>此外，<code>fs</code>模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。同步API除了方法名的末尾多了一个<code>Sync</code>之外，异常对象与执行结果的传递方式也有相应变化。同样以<code>fs.readFileSync</code>为例：<br>try {<br>    var data = fs.readFileSync(pathname);<br>    // Deal with data.<br>} catch (err) {<br>    // Deal with error.<br>}</p>
<p><code>fs</code>模块提供的API很多，这里不一一介绍，需要时请自行查阅官方文档。</p>
<h2 id="Path（路径）">Path（路径）</h2><p><code>官方文档： http://nodejs.org/api/path.html</code><br>操作文件时难免不与文件路径打交道。NodeJS提供了<code>path</code>内置模块来简化路径相关操作，并提升代码可读性。以下分别介绍几个常用的API。</p>
<ul>
<li><p>path.normalize<br>  将传入的路径转换为标准路径，具体讲的话，除了解析路径中的.与..外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">store</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    cache[path.normalize(key)] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store(<span class="string">'foo/bar'</span>, <span class="number">1</span>);</span><br><span class="line">store(<span class="string">'foo//baz//../bar'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cache);  <span class="comment">// =&gt; &#123; "foo/bar": 2 &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>标准化之后的路径里的斜杠在Windows系统下是<code>\</code>，而在Linux系统下是<code>/</code>。如果想保证任何系统下都使用/作为路径分隔符的话，需要用<code>.replace(/\\/g, &#39;/&#39;)</code>再替换一下标准路径。</p>
</blockquote>
</li>
<li><p>path.join<br>  将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">'foo/'</span>, <span class="string">'baz/'</span>, <span class="string">'../bar'</span>); <span class="comment">// =&gt; "foo/bar"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>path.extname<br>  当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子：        </p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.extname(<span class="string">'foo/bar.js'</span>); <span class="comment">// =&gt; ".js"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>path</code>模块提供的其余方法也不多，稍微看一下官方文档就能全部掌握。</p>
<h1 id="遍历目录">遍历目录</h1><p>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。</p>
<h2 id="递归算法">递归算法</h2><p>遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。</p>
<blockquote>
<p>使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。</p>
</blockquote>
<h2 id="遍历算法">遍历算法</h2><p>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是<code>A &gt; B &gt; D &gt; E &gt; C &gt; F</code>。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  B   C</span><br><span class="line"> / <span class="string">\</span>   <span class="string">\</span></span><br><span class="line">D   E   F</span><br></pre></td></tr></table></figure></p>
<h3 id="同步遍历">同步遍历</h3><p>了解了必要的算法后，我们可以简单地实现以下目录遍历函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">    fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pathname = path.join(dir, file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fs.statSync(pathname).isDirectory()) &#123;</span><br><span class="line">            travel(pathname, callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback(pathname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- <span class="regexp">/home/u</span>ser/</span><br><span class="line">    - foo/</span><br><span class="line">        x.js</span><br><span class="line">    - bar/</span><br><span class="line">        y.js</span><br><span class="line">    z.css</span><br></pre></td></tr></table></figure></p>
<p>使用以下代码遍历该目录时，得到的输入如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">travel(<span class="string">'/home/user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pathname);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line"><span class="regexp">/home/u</span>ser/foo/x.js</span><br><span class="line">/home/user/bar/y.js</span><br><span class="line">/home/user/z.css</span><br></pre></td></tr></table></figure></p>
<h3 id="异步遍历x">异步遍历x</h3><p>如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。travel函数的异步版本如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback, finish</span>) </span>&#123;</span><br><span class="line">    fs.readdir(dir, <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; files.length) &#123;</span><br><span class="line">                <span class="keyword">var</span> pathname = path.join(dir, files[i]);</span><br><span class="line"></span><br><span class="line">                fs.stat(pathname, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (stats.isDirectory()) &#123;</span><br><span class="line">                        travel(pathname, callback, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                            next(i + <span class="number">1</span>);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        callback(pathname, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                            next(i + <span class="number">1</span>);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish &amp;&amp; finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(<span class="number">0</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里不详细介绍异步遍历函数的编写技巧，我们可以看到异步编程还是蛮复杂的。</p>
<h1 id="文本编码">文本编码</h1><p>使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有<code>UTF8</code>和<code>GBK</code>两种，并且<code>UTF8</code>文件还可能带有<code>BOM</code>。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的<code>UTF8</code>编码字符串后才能正常处理。</p>
<h2 id="BOM的移除">BOM的移除</h2><p>BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">    Bytes      Encoding</span><br><span class="line">----------------------------</span></span><br><span class="line"><span class="code">    FE FF       UTF16BE</span></span><br><span class="line"><span class="code">    FF FE       UTF16LE</span></span><br><span class="line"><span class="code">    EF BB BF    UTF8</span></span><br></pre></td></tr></table></figure></p>
<p>因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM。例如，以下代码实现了识别和去除UTF8 BOM的功能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readText</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bin = fs.readFileSync(pathname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bin[<span class="number">0</span>] === <span class="number">0xEF</span> &amp;&amp; bin[<span class="number">1</span>] === <span class="number">0xBB</span> &amp;&amp; bin[<span class="number">2</span>] === <span class="number">0xBF</span>) &#123;</span><br><span class="line">        bin = bin.slice(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bin.toString(<span class="string">'utf-8'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GBK转UTF8">GBK转UTF8</h2><p>NodeJS支持在读取文本文件时，或者在<code>Buffer</code>转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助<code>iconv-lite</code>这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readGBKText</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bin = fs.readFileSync(pathname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iconv.decode(bin, <span class="string">'gbk'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="单字节编码">单字节编码</h2><p>有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。</p>
<p>首先我们知道，如果一个文本文件只包含英文字符，比如Hello World，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。</p>
<p>反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> GBK编码源文件内容：</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">'中文'</span>;</span><br><span class="line"><span class="number">2.</span> 对应字节：</span><br><span class="line">    <span class="number">76</span> <span class="number">61</span> <span class="number">72</span> <span class="number">20</span> <span class="number">66</span> <span class="number">6</span>F <span class="number">6</span>F <span class="number">20</span> <span class="number">3</span>D <span class="number">20</span> <span class="number">27</span> D6 D0 CE C4 <span class="number">27</span> <span class="number">3</span>B</span><br><span class="line"><span class="number">3.</span> 使用单字节编码读取后得到的内容：</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">'&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;'</span>;</span><br><span class="line"><span class="number">4.</span> 替换内容：</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">'&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;'</span>;</span><br><span class="line"><span class="number">5.</span> 使用单字节编码保存后对应字节：</span><br><span class="line">    <span class="number">76</span> <span class="number">61</span> <span class="number">72</span> <span class="number">20</span> <span class="number">62</span> <span class="number">61</span> <span class="number">72</span> <span class="number">20</span> <span class="number">3</span>D <span class="number">20</span> <span class="number">27</span> D6 D0 CE C4 <span class="number">27</span> <span class="number">3</span>B</span><br><span class="line"><span class="number">6.</span> 使用GBK编码读取后得到内容：</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">'中文'</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里的诀窍在于，不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。</p>
<p>NodeJS中自带了一种<code>binary</code>编码可以用来实现这个方法，因此在下例中，我们使用这种编码来演示上例对应的代码该怎么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = fs.readFileSync(pathname, <span class="string">'binary'</span>);</span><br><span class="line">    str = str.replace(<span class="string">'foo'</span>, <span class="string">'bar'</span>);</span><br><span class="line">    fs.writeFileSync(pathname, str, <span class="string">'binary'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/06/node-code/" itemprop="url">
                Node.js 之 代码的组织和部署
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-06T10:15:20+08:00" content="2016-01-06">
            2016-01-06
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/javascript/" itemprop="url" rel="index">
                  <span itemprop="name">javascript</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/06/node-code/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/06/node-code/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="模块路径解析规则">模块路径解析规则</h1><p>我们已经知道，<code>require</code>函数支持<code>斜杠（/）</code>或<code>盘符（C:）</code>开头的绝对路径，也支持<code>./</code>开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。因此，require函数支持第三种形式的路径，写法类似于<code>foo/bar</code>，并依次按照以下规则解析路径，直到找到模块位置。</p>
<ol>
<li><p>内置模块<br> 如果传递给<code>require</code>函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如<code>require(&#39;fs&#39;)</code>。</p>
</li>
<li><p>node_modules目录<br> NodeJS定义了一个特殊的<code>node_modules</code>目录用于存放模块。例如某个模块的绝对路径是<code>/home/user/hello.js</code>，在该模块中使用<code>require(&#39;foo/bar&#39;)</code>方式加载模块时，则NodeJS依次尝试使用以下路径。    </p>
 <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/home/</span>user<span class="regexp">/node_modules/</span>foo/bar</span><br><span class="line"><span class="regexp">/home/</span>node_modules<span class="regexp">/foo/</span>bar</span><br><span class="line"><span class="regexp">/node_modules/</span>foo/bar</span><br></pre></td></tr></table></figure>
</li>
<li><p>NODE_PATH环境变量<br> 与PATH环境变量类似，NodeJS允许通过<code>NODE_PATH</code>环境变量来指定额外的模块搜索路径。<code>NODE_PATH</code>环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下<code>NODE_PATH</code>环境变量：    </p>
 <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">NODE_PATH</span>=<span class="regexp">/home/user</span><span class="regexp">/lib:/home</span><span class="regexp">/lib</span></span><br></pre></td></tr></table></figure>
<p> 当使用<code>require(&#39;foo/bar&#39;)</code>的方式加载模块时，则NodeJS依次尝试以下路径。</p>
 <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/user/<span class="class"><span class="keyword">lib</span>/<span class="title">foo</span>/<span class="title">bar</span></span></span><br><span class="line">	/home/<span class="class"><span class="keyword">lib</span>/<span class="title">foo</span>/<span class="title">bar</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="包（package）">包（package）</h1><blockquote>
<p>我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做<code>包</code>，并把所有子模块放在同一个目录里。</p>
</blockquote>
<p>在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- /home/user/lib/</span><br><span class="line">    - cat/</span><br><span class="line">        head<span class="class">.js</span></span><br><span class="line">        <span class="tag">body</span><span class="class">.js</span></span><br><span class="line">        main.js</span><br></pre></td></tr></table></figure></p>
<p>其中<code>cat</code>目录定义了一个<code>包</code>，其中包含了3个子模块。<code>main.js</code>作为入口模块，其内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="built_in">require</span>(<span class="string">'./head'</span>);</span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">require</span>(<span class="string">'./body'</span>);</span><br><span class="line"></span><br><span class="line">exports.create = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        head: head.create(),</span><br><span class="line">        body: body.create()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在其它模块里使用包的时候，需要加载包的入口模块。接着上例，使用<code>require(&#39;/home/user/lib/cat/main&#39;)</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。</p>
<h2 id="index-js">index.js</h2><p>当模块的文件名是<code>index.js</code>，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="built_in">require</span>(<span class="string">'/home/user/lib/cat'</span>);</span><br><span class="line"><span class="keyword">var</span> cat = <span class="built_in">require</span>(<span class="string">'/home/user/lib/cat/index'</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样处理后，就只需要把包目录路径传递给<code>require</code>函数，感觉上整个目录被当作单个模块使用，更有整体感。</p>
<h2 id="package-json">package.json</h2><p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个<code>package.json</code>文件，并在其中指定入口模块的路径。上例中的cat模块可以重构如下。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- <span class="regexp">/home/user</span><span class="regexp">/lib/</span></span><br><span class="line">    - cat/</span><br><span class="line">        + doc/</span><br><span class="line">        - <span class="class"><span class="keyword">lib</span>/</span></span><br><span class="line">            head.js</span><br><span class="line">            body.js</span><br><span class="line">            main.js</span><br><span class="line">        + tests/</span><br><span class="line">        package.json</span><br></pre></td></tr></table></figure></p>
<p>其中<code>package.json</code>内容如下。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">name</span>": <span class="value"><span class="string">"cat"</span></span>,</span><br><span class="line">    "<span class="attribute">main</span>": <span class="value"><span class="string">"./lib/main.js"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此一来，就同样可以使用<code>require(&#39;/home/user/lib/cat&#39;)</code>的方式加载模块。NodeJS会根据包目录下的<code>package.json</code>找到入口模块所在位置。</p>
<h1 id="命令行程序">命令行程序</h1><p>使用NodeJS编写的东西，要么是一个<code>包</code>，要么是一个<code>命令行程序</code>，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p>
<p>例如我们用NodeJS写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在<code>/home/user/bin/node-echo.js</code>这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node <span class="regexp">/home/u</span>ser<span class="regexp">/bin/</span>node-echo.js Hello World</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p>
<p>这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>node-echo <span class="constant">Hello</span> <span class="constant">World</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Linux">Linux</h2><p>在Linux系统下，我们可以把JS文件当作shell脚本来运行，从而达到上述目的，具体步骤如下：</p>
<ol>
<li><p>在shell脚本中，可以通过<code>#!</code>注释来指定当前脚本使用的解析器。所以我们首先在<code>node-echo.js</code>文件顶部增加以下一行注释，表明当前脚本使用NodeJS解析。</p>
 <figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /usr/bin/env node</span></span><br></pre></td></tr></table></figure>
<p> NodeJS会忽略掉位于JS模块首行的<code>#!</code>注释，不必担心这行注释是非法语句。</p>
</li>
<li><p>然后，我们使用以下命令赋予<code>node-echo.js</code>文件执行权限。</p>
 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x <span class="regexp">/home/u</span>ser<span class="regexp">/bin/</span>node-echo.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们在<code>PATH</code>环境变量中指定的某个目录下，例如在<code>/usr/local/bin</code>下边创建一个<code>软链文件</code>，文件名与我们希望使用的终端命令同名，命令如下：</p>
 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s <span class="regexp">/home/u</span>ser<span class="regexp">/bin/</span>node-echo.js <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>node-echo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样处理后，我们就可以在任何目录下使用<code>node-echo</code>命令了。</p>
<h2 id="Windows">Windows</h2><p>在Windows系统下的做法完全不同，我们得靠.cmd文件来解决问题。假设<code>node-echo.js</code>存放在<code>C:\Users\user\bin</code>目录，并且该目录已经添加到<code>PATH</code>环境变量里了。接下来需要在该目录下新建一个名为<code>node-echo.cmd</code>的文件，文件内容如下：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@node "C:<span class="command">\User</span><span class="command">\user</span><span class="command">\bin</span><span class="command">\node</span>-echo.js" <span class="comment">%*</span></span><br></pre></td></tr></table></figure></p>
<p>这样处理后，我们就可以在任何目录下使用<code>node-echo</code>命令了。</p>
<h1 id="工程目录">工程目录</h1><p>了解了以上知识后，现在我们可以来完整地规划一个工程目录了。以编写一个命令行程序为例，一般我们会同时提供命令行模式和API模式两种使用方式，并且我们会借助三方包来编写代码。除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- <span class="regexp">/home/user</span><span class="regexp">/workspace/node</span>-echo/   <span class="comment"># 工程目录</span></span><br><span class="line">    - bin/                          <span class="comment"># 存放命令行相关代码</span></span><br><span class="line">        node-echo</span><br><span class="line">    + doc/                          <span class="comment"># 存放文档</span></span><br><span class="line">    - <span class="class"><span class="keyword">lib</span>/                          <span class="comment"># 存放API相关代码</span></span></span><br><span class="line">        echo.js</span><br><span class="line">    - node_modules/                 <span class="comment"># 存放三方包</span></span><br><span class="line">        + argv/</span><br><span class="line">    + tests/                        <span class="comment"># 存放测试用例</span></span><br><span class="line">    package.json                    <span class="comment"># 元数据文件</span></span><br><span class="line">    <span class="constant">README</span>.md                       <span class="comment"># 说明文件</span></span><br></pre></td></tr></table></figure></p>
<p>其中部分文件内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bin/node-echo */</span></span><br><span class="line"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'argv'</span>),</span><br><span class="line">    echo = <span class="built_in">require</span>(<span class="string">'../lib/echo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(echo(argv.join(<span class="string">' '</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* lib/echo.js */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* package.json */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"node-echo"</span>,</span><br><span class="line">    <span class="string">"main"</span>: <span class="string">"./lib/echo.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上例子中分类存放了不同类型的文件，并通过<code>node_moudles</code>目录直接使用三方包名加载模块。此外，定义了<code>package.json</code>之后，<code>node-echo</code>目录也可被当作一个包来使用。</p>
<h1 id="NPM">NPM</h1><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<h2 id="下载三方包">下载三方包</h2><p>需要使用三方包时，首先得知道有哪些包可用。虽然<code>npmjs.org</code>提供了个搜索框可以根据包名来搜索，但如果连想使用的三方包的名字都不确定的话，就请百度一下吧。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install argv</span><br><span class="line">...</span><br><span class="line">argv@<span class="number">0.0</span><span class="number">.2</span> node_modules\argv</span><br></pre></td></tr></table></figure></p>
<p>下载好之后，<code>argv</code>包就放在了工程目录下的<code>node_modules</code>目录中，因此在代码中只需要通过<code>require(&#39;argv&#39;)</code>的方式就好，无需指定三方包路径。</p>
<p>以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上<code>@&lt;version&gt;</code>，例如通过以下命令可下载0.0.1版的argv：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install argv@<span class="number">0.0</span><span class="number">.1</span></span><br><span class="line">...</span><br><span class="line">argv@<span class="number">0.0</span><span class="number">.1</span> node_modules\argv</span><br></pre></td></tr></table></figure></p>
<p>如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对<code>package.json</code>的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的<code>package.json</code>可以改写如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">name</span>": <span class="value"><span class="string">"node-echo"</span></span>,</span><br><span class="line">    "<span class="attribute">main</span>": <span class="value"><span class="string">"./lib/echo.js"</span></span>,</span><br><span class="line">    "<span class="attribute">dependencies</span>": <span class="value">&#123;</span><br><span class="line">        "<span class="attribute">argv</span>": <span class="value"><span class="string">"0.0.2"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样处理后，在工程目录下就可以使用<code>npm install</code>命令批量安装三方包了。更重要的是，当以后<code>node-echo</code>也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用<code>npm install node-echo</code>命令时，NPM会自动创建以下目录结构。<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> project/</span><br><span class="line"></span>    -<span class="ruby"> node_modules/</span><br><span class="line"></span>        -<span class="ruby"> node-echo/</span><br><span class="line"></span>            -<span class="ruby"> node_modules/</span><br><span class="line"></span>                + argv/</span><br><span class="line">            ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。</p>
<h2 id="发布代码">发布代码</h2><p>第一次使用NPM发布代码前需要注册一个账号。终端下运行<code>npm adduser</code>，之后按照提示做即可。账号搞定后，接着我们需要编辑<code>package.json</code>文件，加入NPM必需的字段。<code>package.json</code>里必要的字段如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "name": "node-echo",           # 包名，在NPM服务器上须要保持唯一</span><br><span class="line">    "version": "1.0.0",            # 当前版本号</span><br><span class="line">    "dependencies": &#123;              # 三方包依赖，需要指定包名和版本号</span><br><span class="line">        "argv": "0.0.2"</span><br><span class="line">      &#125;,</span><br><span class="line">    "main": "./lib/echo.js",       # 入口模块位置</span><br><span class="line">    "bin" : &#123;</span><br><span class="line">        "node-echo": "./bin/node-echo"      # 命令行程序名和主模块位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后，我们就可以在<code>package.json</code>所在目录下运行<code>npm publish</code>发布代码了。</p>
<h2 id="版本号">版本号</h2><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>
<p>语义版本号分为<code>X.Y.Z</code>三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>如果只是修复bug，需要更新Z位。</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>如果是新增了功能，但是向下兼容，需要更新Y位。</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>如果有大变动，向下不兼容，需要更新X位。</span><br></pre></td></tr></table></figure></p>
<p>版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。NPM支持的所有版本号范围指定方式可以查看官方文档 <code>https://npmjs.org/doc/files/package.json.html#dependencies</code>。</p>
<p>这里再介绍一些NPM常用命令。</p>
<ul>
<li>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</li>
<li>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</li>
<li>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用<code>npm update &lt;package&gt;</code>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</li>
<li>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/05/nodejs-modular/" itemprop="url">
                Node.js 之 模块
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-05T09:57:20+08:00" content="2016-01-05">
            2016-01-05
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/javascript/" itemprop="url" rel="index">
                  <span itemprop="name">javascript</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/05/nodejs-modular/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/05/nodejs-modular/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="nodejs_模块">nodejs 模块</h1><blockquote>
<p>编写稍大一点的程序时一般都会将代码模块化。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。</p>
</blockquote>
<p>在编写每个模块时，都有<code>require</code>、<code>exports</code>、<code>module</code>三个预先定义好的变量可供使用。</p>
<h2 id="require">require</h2><p><code>require</code>函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。以下是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo1 = <span class="built_in">require</span>(<span class="string">'./foo'</span>);</span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>);</span><br><span class="line"><span class="keyword">var</span> foo3 = <span class="built_in">require</span>(<span class="string">'/home/user/foo'</span>);</span><br><span class="line"><span class="keyword">var</span> foo4 = <span class="built_in">require</span>(<span class="string">'/home/user/foo.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo1至foo4中保存的是同一个模块的导出对象。</span></span><br></pre></td></tr></table></figure></p>
<p>另外，可以使用以下方式加载和使用一个JSON文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="built_in">require</span>(<span class="string">'./data.json'</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="exports">exports</h2><p><code>exports</code>对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过<code>require</code>函数使用当前模块时得到的就是当前模块的<code>exports</code>对象。以下例子中导出了一个公有方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="module">module</h2><p>通过<code>module</code>对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上代码中，模块默认导出对象被替换为一个函数。</p>
<h2 id="模块初始化">模块初始化</h2><blockquote>
<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</p>
</blockquote>
<h2 id="主模块">主模块</h2><p>通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，<code>main.js</code>就是主模块。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>node main.js</span><br></pre></td></tr></table></figure></p>
<p>例如有以下目录：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> /home/user/hello/</span><br><span class="line"></span>    -<span class="ruby"> util/</span><br><span class="line"></span>        counter.js</span><br><span class="line">    main.js</span><br></pre></td></tr></table></figure></p>
<p>其中counter.js内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.count = count;</span><br></pre></td></tr></table></figure></p>
<p>该模块内部定义了一个私有变量<code>i</code>，并在<code>exports</code>对象导出了一个公有方法<code>count</code>。<br>主模块main.js内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter1 = <span class="built_in">require</span>(<span class="string">'./util/counter'</span>);</span><br><span class="line"><span class="keyword">var</span> counter2 = <span class="built_in">require</span>(<span class="string">'./util/counter'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter1.count());</span><br><span class="line"><span class="built_in">console</span>.log(counter2.count());</span><br><span class="line"><span class="built_in">console</span>.log(counter2.count());</span><br></pre></td></tr></table></figure></p>
<p>运行该程序的结果如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，<code>counter.js</code>并没有因为被<code>require</code>了两次而初始化两次。</p>
<h2 id="二进制模块">二进制模块</h2><p>虽然一般我们使用JS编写模块，但NodeJS也支持使用C/C++编写二进制模块。编译好的二进制模块除了文件扩展名是.node外，和JS模块的使用方式相同。二进制模块能使用操作系统提供的所有功能，拥有无限的潜能。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/04/node-async/" itemprop="url">
                Node.js 之 异步编程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2016-01-04T11:45:20+08:00" content="2016-01-04">
            2016-01-04
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/javascript/" itemprop="url" rel="index">
                  <span itemprop="name">javascript</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/04/node-async/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/04/node-async/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>NodeJS最大的卖点——事件机制和异步IO，对开发者并不是透明的。开发者需要按异步方式编写代码才用得上这个卖点，而这一点也遭到了一些NodeJS反对者的抨击。但不管怎样，异步编程确实是NodeJS最大的特点，没有掌握异步编程就不能说是真正学会了NodeJS。</p>
<h1 id="回调">回调</h1><p>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。我们首先可以看看以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heavyCompute</span>(<span class="params">n, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>,</span><br><span class="line">        i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callback(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">heavyCompute(<span class="number">10000</span>, <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">-- Console ------------------------------</span><br><span class="line"><span class="number">100000000</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>可以看到，以上代码中的回调函数仍然先于后续代码执行。JS本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。</p>
<p>但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。我们接着看看以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">-- Console ------------------------------</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure></p>
<p>这次可以看到，回调函数后于后续代码执行了。如同上边所说，JS本身是单线程的，无法异步执行，因此我们可以认为<code>setTimeout</code>这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了<code>setTimeout</code>、<code>setInterval</code>这些常见的，这类函数还包括NodeJS提供的诸如<code>fs.readFile</code>之类的异步API。</p>
<p>另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。以下就是这么一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heavyCompute</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>,</span><br><span class="line">        i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() - t);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">heavyCompute(<span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line">-- Console ------------------------------</span><br><span class="line"><span class="number">8520</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，本来应该在1秒后被调用的回调函数因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。</p>
<h1 id="代码设计模式">代码设计模式</h1><p>异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。</p>
<h2 id="函数返回值">函数返回值</h2><p>使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> output = fn1(fn2(<span class="string">'input'</span>));</span><br><span class="line"><span class="comment">// Do something.</span></span><br></pre></td></tr></table></figure></p>
<p>而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn2(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">output2</span>) </span>&#123;</span><br><span class="line">    fn1(output2, <span class="function"><span class="keyword">function</span> (<span class="params">output1</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Do something.</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这种方式就是一个回调函数套一个回调函多，套得太多了很容易写出<code>&gt;</code>形状的代码。</p>
<h2 id="遍历数组">遍历数组</h2><p>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len = arr.length,</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; i &lt; len; ++i) &#123;</span><br><span class="line">    arr[i] = sync(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All array items have processed.</span></span><br></pre></td></tr></table></figure></p>
<p>如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">i, len, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">async</span>(arr[i], <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            arr[i] = value;</span><br><span class="line">            next(i + <span class="number">1</span>, len, callback);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="number">0</span>, arr.length, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// All array items have processed.</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p>
<p>可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。</p>
<p>如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">i, len, count, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; len; ++i) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">async</span>(arr[i], <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                arr[i] = value;</span><br><span class="line">                <span class="keyword">if</span> (++count === len) &#123;</span><br><span class="line">                    callback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="number">0</span>, arr.length, <span class="number">0</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// All array items have processed.</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p>
<p>可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。</p>
<h2 id="异常处理">异常处理</h2><p>JS自身提供的异常捕获和处理机制——try..catch..，只能用于同步执行的代码。以下是一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sync</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sync(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error: %s'</span>, err.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- Console ------------------------------</span><br><span class="line"><span class="built_in">Error</span>: object is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个<code>try</code>语句时被捕获住。<br>但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到<code>try</code>语句，就作为一个全局异常抛出。以下是一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code execution path breaks here.</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)　</span>&#123;</span><br><span class="line">        callback(fn());</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">async</span>(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Do something.</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error: %s'</span>, err.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- Console ------------------------------</span><br><span class="line"><span class="regexp">/home/u</span>ser/test.js:<span class="number">4</span></span><br><span class="line">        callback(fn());</span><br><span class="line">                 ^</span><br><span class="line"><span class="built_in">TypeError</span>: object is not a <span class="function"><span class="keyword">function</span></span><br><span class="line">    <span class="title">at</span> <span class="title">null</span>.<span class="title">_onTimeout</span> (<span class="params">/home/user/test.js:4:13</span>)</span><br><span class="line">    <span class="title">at</span> <span class="title">Timer</span>.<span class="title">listOnTimeout</span>(<span class="params">timers.js:110:15</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用<code>try</code>语句把异常捕获住，并通过回调函数传递被捕获的异常。于是我们可以像下边这样改造上边的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">fn, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code execution path breaks here.</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)　</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callback(<span class="literal">null</span>, fn());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            callback(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Error: %s'</span>, err.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Do something.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">-- Console ------------------------------</span><br><span class="line"><span class="built_in">Error</span>: object is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，异常再次被捕获住了。在NodeJS中，几乎所有异步API都按照以上方式设计，回调函数中第一个参数都是<code>err</code>。因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与NodeJS的设计风格保持一致。</p>
<p>有了异常处理方式后，我们接着可以想一想一般我们是怎么写代码的。基本上，我们的代码都是做一些事情，然后调用一个函数，然后再做一些事情，然后再调用一个函数，如此循环。如果我们写的是同步代码，只需要在代码入口点写一个try语句就能捕获所有冒泡上来的异常，示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">    syncA();</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">    syncB();</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">    syncC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    main();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// Deal with exception.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，如果我们写的是异步代码，就只有呵呵了。由于每次异步函数调用都会打断代码执行路径，只能通过回调函数来传递异常，于是我们就需要在每个回调函数里判断是否有异常发生，于是只用三次异步函数调用，就会产生下边这种代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">    asyncA(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            callback(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Do something</span></span><br><span class="line">            asyncB(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    callback(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Do something</span></span><br><span class="line">                    asyncC(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                            callback(err);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// Do something</span></span><br><span class="line">                            callback(<span class="literal">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// Deal with exception.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，回调函数已经让代码变得复杂了，而异步方式下对异常的处理更加剧了代码的复杂度。如果NodeJS的最大卖点最后变成这个样子，那就没人愿意用NodeJS了，因此接下来会介绍NodeJS提供的一些解决方案。</p>
<h1 id="域（Domain）">域（Domain）</h1><p><code>官方文档： http://nodejs.org/api/domain.html</code><br>NodeJS提供了<code>domain</code>模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解“域”的概念。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过<code>process</code>对象提供了捕获全局异常的方法，示例代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error: %s'</span>, err.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">-- Console ------------------------------</span><br><span class="line"><span class="built_in">Error</span>: <span class="literal">undefined</span> is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure></p>
<p>虽然全局异常有个地方可以捕获了，但是对于大多数异常，我们希望尽早捕获，并根据结果决定代码的执行路径。我们用以下HTTP服务器代码作为例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">request, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">    asyncA(request, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            callback(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Do something</span></span><br><span class="line">            asyncB(request, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    callback(err);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Do something</span></span><br><span class="line">                    asyncC(request, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                            callback(err);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// Do something</span></span><br><span class="line">                            callback(<span class="literal">null</span>, data);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">async</span>(request, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            response.writeHead(<span class="number">500</span>);</span><br><span class="line">            response.end();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            response.end(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上代码将请求对象交给异步函数处理后，再根据处理结果返回响应。这里采用了使用回调函数传递异常的方案，因此<code>async</code>函数内部如果再多几个异步函数调用的话，代码就变成上边这副鬼样子了。为了让代码好看点，我们可以在每处理一个请求时，使用<code>domain</code>模块创建一个子域（JS子运行环境）。在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的<code>error</code>事件统一捕获。于是以上代码可以做如下改造：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">request, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">    asyncA(request, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">        asyncB(request, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// Do something</span></span><br><span class="line">            asyncC(request, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// Do something</span></span><br><span class="line">                callback(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> d = domain.create();</span><br><span class="line"></span><br><span class="line">    d.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        response.writeHead(<span class="number">500</span>);</span><br><span class="line">        response.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    d.run(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">async</span>(request, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            response.end(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们使用<code>.create</code>方法创建了一个子域对象，并通过<code>.run</code>方法进入需要在子域中运行的代码的入口点。而位于子域中的异步函数回调函数由于不再需要捕获异常，代码一下子瘦身很多。</p>
<h2 id="陷阱">陷阱</h2><blockquote>
<p>无论是通过<code>process</code>对象的<code>uncaughtException</code>事件捕获到全局异常，还是通过子域对象的error事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。按照官方文档的说法，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。</p>
<p>但这里需要澄清一些事实。JS本身的<code>throw..try..catch</code>异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但NodeJS并不是存粹的JS。NodeJS里大量的API内部是用C/C++实现的，因此NodeJS程序的运行过程中，代码执行路径穿梭于JS引擎内部和外部，而JS的异常抛出机制可能会打断正常的代码执行流程，导致C/C++部分的代码表现异常，进而导致内存泄漏等问题。</p>
<p>因此，使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了C/C++部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用try语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上诉问题。</p>
</blockquote>
<h1 id="小结">小结</h1><ul>
<li>不掌握异步编程就不算学会NodeJS。</li>
<li>异步编程依托于回调来实现，而使用回调不一定就是异步编程。</li>
<li>异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别。</li>
<li>使用<code>domain</code>模块简化异步代码的异常处理，并小心陷阱。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/31/linux-command/" itemprop="url">
                WEB后端开发必会的Linux命令
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-12-31T11:47:20+08:00" content="2015-12-31">
            2015-12-31
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/web/" itemprop="url" rel="index">
                  <span itemprop="name">web</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/31/linux-command/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/31/linux-command/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>作为一个WEB后端开发人员，有些常用的Linux命令必须掌握。即时平时开发过程中不使用Linux（Unix）或者mac系统，也需要熟练掌握Linux命令。因为很多服务器上都是Linux系统。所以，要和服务器机器交互，就要通过shell命令。</p>
</blockquote>
<p>本文并不会对所有命令进行详细讲解，只给出常见用法和解释。具体用法可以使用–help查看帮助或者直接通过google搜索学习。</p>
<h1 id="查找文件">查找文件</h1><ul>
<li><code>find / -name filename.txt</code> 根据名称查找<code>/</code>目录下的<code>filename.txt</code>文件。</li>
<li><code>find . -name &quot;*.xml&quot;</code> 递归查找所有的<code>xml文件</code></li>
<li><code>find . -name &quot;*.xml&quot; |xargs grep &quot;hello world&quot;</code> 递归查找所有文件内容中包含<code>hello world</code>的xml文件</li>
<li><code>grep -H &#39;spring&#39; *.xml</code> 查找所以有的包含<code>spring</code>的xml文</li>
<li><code>find ./ -size 0 | xargs rm -f &amp;</code> 删除文件大小为零的文件</li>
<li><code>ls -l | grep &#39;.jar&#39;</code> 查找当前目录中的所有<code>jar</code>文件</li>
<li><code>grep &#39;test&#39; d*</code> 显示所有<code>以d开头</code>的文件中包含<code>test</code>的行。</li>
<li><code>grep &#39;test&#39; aa bb cc</code> 显示在<code>aa，bb，cc</code>文件中匹配<code>test</code>的行。</li>
<li><code>grep &#39;[a-z]\{5\}&#39; aa</code> 显示所有<code>包含每个字符串至少有5个连续小写字符</code>的字符串的行。</li>
</ul>
<h1 id="查看一个程序是否运行">查看一个程序是否运行</h1><ul>
<li><code>ps –ef|grep nginx</code> 查看所有有关<code>nginx</code>的进程</li>
</ul>
<h1 id="终止线程">终止线程</h1><ul>
<li><code>kill -9 19979</code> 终止<code>线程号位19979</code>的进程</li>
<li><code>kill -9 tomcat</code> 终止<code>线程名tomcat</code>的进程</li>
</ul>
<h1 id="查看文件，包含隐藏文件">查看文件，包含隐藏文件</h1><ul>
<li><code>ls -al</code></li>
</ul>
<h1 id="当前工作目录">当前工作目录</h1><ul>
<li><code>pwd</code></li>
</ul>
<h1 id="复制文件">复制文件</h1><ul>
<li><code>cp source dest</code> 复制文件</li>
<li><code>cp -r sourceFolder targetFolder</code> 递归复制整个文件夹</li>
<li><code>scp sourecFile romoteUserName@remoteIp:remoteAddr</code> 远程拷贝</li>
</ul>
<h1 id="创建目录">创建目录</h1><ul>
<li><code>mkdir newfolder</code></li>
</ul>
<h1 id="删除目录">删除目录</h1><ul>
<li><code>rmdir deleteEmptyFolder</code> 删除空目录 </li>
<li><code>rm -rf deleteFile</code> 递归删除目录中所有内容</li>
</ul>
<h1 id="移动文件">移动文件</h1><ul>
<li><code>mv /temp/movefile /targetFolder</code></li>
</ul>
<h1 id="重命令">重命令</h1><ul>
<li><code>mv oldNameFile newNameFile</code> </li>
</ul>
<h1 id="切换用户">切换用户</h1><ul>
<li><code>su -username</code></li>
</ul>
<h1 id="修改文件权限">修改文件权限</h1><ul>
<li><code>chmod 777 file.java</code>  <code>file.java</code>的权限<code>-rwxrwxrwx</code>，<code>r</code>表示读、<code>w</code>表示写、<code>x</code>表示可执行</li>
</ul>
<h1 id="压缩文件">压缩文件</h1><ul>
<li><code>tar -czf test.tar.gz /test1 /test2</code> </li>
</ul>
<h1 id="列出压缩文件列表">列出压缩文件列表</h1><ul>
<li><code>tar -tzf test.tar.gz</code></li>
</ul>
<h1 id="解压文件">解压文件</h1><ul>
<li><code>tar -xvzf test.tar.gz</code></li>
</ul>
<h1 id="查看文件头10行">查看文件头10行</h1><ul>
<li><code>head -n 10 example.txt</code></li>
</ul>
<h1 id="查看文件尾10行">查看文件尾10行</h1><ul>
<li><code>tail -n 10 example.txt</code></li>
</ul>
<h1 id="查看日志类型文件">查看日志类型文件</h1><ul>
<li><code>tail -f exmaple.log</code> 这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。</li>
</ul>
<h1 id="使用超级管理员身份执行命令">使用超级管理员身份执行命令</h1><ul>
<li><code>sudo rm a.txt</code> 使用管理员身份删除文件</li>
</ul>
<h1 id="查看端口占用情况">查看端口占用情况</h1><ul>
<li><code>netstat -tln | grep 8080</code> 查看端口8080的使用情况</li>
</ul>
<h1 id="查看端口属于哪个程序">查看端口属于哪个程序</h1><ul>
<li><code>lsof -i :8080</code></li>
</ul>
<h1 id="查看进程">查看进程</h1><ul>
<li><code>ps aux|grep java</code> 查看java进程</li>
<li><code>ps aux</code> 查看所有进程</li>
</ul>
<h1 id="以树状图列出目录的内容">以树状图列出目录的内容</h1><ul>
<li><code>tree a</code> </li>
</ul>
<h1 id="文件下载">文件下载</h1><ul>
<li><code>wget http://file.tgz</code></li>
<li><code>curl http://file.tgz</code></li>
</ul>
<h1 id="网络检测">网络检测</h1><ul>
<li><code>ping www.just-ping.com</code></li>
</ul>
<h1 id="远程登录">远程登录</h1><ul>
<li><code>ssh userName@ip</code></li>
</ul>
<h1 id="打印信息">打印信息</h1><p><code>echo $JAVA_HOME</code> 打印java home环境变量的值</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/linux-centos7-nodejs-mongodb-nginx/" itemprop="url">
                在CentOS 7上安装Node.js 、 mongodb 、nginx
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-12-30T12:30:20+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/web/" itemprop="url" rel="index">
                  <span itemprop="name">web</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/30/linux-centos7-nodejs-mongodb-nginx/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/30/linux-centos7-nodejs-mongodb-nginx/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="CentOS_7上安装_nodejs_的_3_种方法">CentOS 7上安装 nodejs 的 3 种方法</h1><h2 id="一、源码安装">一、源码安装</h2><ol>
<li><p>下载源码（官网查看最新版本链接）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://npm.taobao.org/mirrors/node/v5.<span class="number">3.0</span>/node-v5.<span class="number">3.0</span>.tar.gz  <span class="comment"># 使用淘宝的镜像</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解压源码</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf node-v* &amp;&amp; <span class="built_in">cd</span> node-v*</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装必要的编译软件 gcc c++</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gcc gcc-c++</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译&amp;安装</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看版本（测试安装是否成功）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v	</span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二、使用已编译版本安装">二、使用已编译版本安装</h2><ol>
<li><p>下载已编译版本    </p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># http:<span class="comment">//npm.taobao.org/mirrors/node/latest/   //淘宝镜像地址</span></span></span><br><span class="line"></span><br><span class="line">cd ~</span><br><span class="line">wget http:<span class="comment">//npm.taobao.org/mirrors/node/latest/node-v5.3.0-linux-x64.tar.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解压</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar --strip-components <span class="number">1</span> -xzvf node-v* -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看版本（测试安装是否成功）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v	</span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="通过NVM安装">通过NVM安装</h2><blockquote>
<p>NVM（Node version manager）顾名思义，就是Node.js的版本管理软件，可以轻松的在Node.js各个版本间切换，项目源码 GitHub <code>https://github.com/creationix/nvm</code></p>
</blockquote>
<ol>
<li><p>下载并安装NVM脚本</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.<span class="number">30.1</span>/install.sh | bash</span><br></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. ~/.nvm/nvm.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出所需要的版本    </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm list-remote</span><br></pre></td></tr></table></figure>
<p> 返回结果如下</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">. . .</span><br><span class="line">v0.<span class="number">10.29</span></span><br><span class="line">v0.<span class="number">10.30</span></span><br><span class="line"> v0.<span class="number">11.0</span></span><br><span class="line"> v0.<span class="number">11.1</span></span><br><span class="line"> v0.<span class="number">11.2</span></span><br><span class="line"> v0.<span class="number">11.3</span></span><br><span class="line"> v0.<span class="number">11.4</span></span><br><span class="line"> v0.<span class="number">11.5</span></span><br><span class="line"> v0.<span class="number">11.6</span></span><br><span class="line"> v0.<span class="number">11.7</span></span><br><span class="line"> v0.<span class="number">11.8</span></span><br><span class="line"> v0.<span class="number">11.9</span></span><br><span class="line">v0.<span class="number">11.10</span></span><br><span class="line">v0.<span class="number">11.11</span></span><br><span class="line">v0.<span class="number">11.12</span></span><br><span class="line">v0.<span class="number">11.13</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装相应的版本    </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v0.<span class="number">10.30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看已安装的版本    </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvm list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回</span></span><br><span class="line">-&gt;  v0.<span class="number">10.30</span></span><br><span class="line">     system</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换版本    </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use v0.<span class="number">10.30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置默认版本    </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">alias</span> default v0.<span class="number">10.30</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="CentOS_7上安装_MongoDB">CentOS 7上安装 MongoDB</h1><h2 id="方法一_（不推荐）">方法一 （不推荐）</h2><blockquote>
<p>MongoDB 提供了centos yum安装方式。<br>参考：<code>http://docs.mongodb.org/manual/tutorial/install-mongodb-on-red-hat/</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/yum.repos.d/mongodb-org-<span class="number">3.2</span>.repo</span><br></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[mongodb-org-3.2]</span></span><br><span class="line"><span class="setting">name=<span class="value">MongoDB Repository</span></span></span><br><span class="line"><span class="setting">baseurl=<span class="value">https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/<span class="number">3.2</span>/x<span class="number">86_64</span>/</span></span></span><br><span class="line"><span class="setting">gpgcheck=<span class="value"><span class="number">0</span></span></span></span><br><span class="line"><span class="setting">enabled=<span class="value"><span class="number">1</span></span></span></span><br></pre></td></tr></table></figure>
<p>安装mongodb<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mongodb-org</span><br></pre></td></tr></table></figure></p>
<p>等待安装完成后，配置文件在：<code>/etc/mongod.conf</code>  数据文件在：<code>/var/lib/mongo</code>  日志文件在：<code>/var/log/mongodb</code></p>
<p>mongodb服务使用<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">service mongod <span class="built_in">start</span></span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">service mongod <span class="built_in">stop</span></span><br><span class="line"><span class="comment">#重启</span></span><br><span class="line">service mongod restart</span><br><span class="line"><span class="comment">#增加开机启动</span></span><br><span class="line">chkconfig mongod <span class="command"><span class="keyword">on</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="方法二_安装MongoDB">方法二  安装MongoDB</h2><ol>
<li>下载MongoDB（64位）<br><code>http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.6.3.tgz</code></li>
<li><p>安装MongoDB（安装到/usr/local）（可以直接复制到/usr/local目录下）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf mongodb-linux-x86_64-<span class="number">2.6</span>.<span class="number">3</span>.tgz</span><br><span class="line">mv mongodb-linux-x86_64-<span class="number">2.6</span>.<span class="number">3</span> mongodb</span><br><span class="line"><span class="built_in">cd</span> mongodb</span><br><span class="line">mkdir data/db</span><br><span class="line">mkdir logs</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line">vi mongodb.conf </span><br><span class="line">dbpath=/usr/<span class="built_in">local</span>/mongodb/data/db</span><br><span class="line">logpath=/usr/<span class="built_in">local</span>/mongodb/logs/mongodb.log</span><br><span class="line">port=<span class="number">27017</span> </span><br><span class="line">fork=<span class="literal">true</span> </span><br><span class="line">nohttpinterface=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新绑定mongodb的配置文件地址和访问IP</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/mongodb/</span>bin<span class="regexp">/mongod --bind_ip localhost -f /u</span>sr<span class="regexp">/local/m</span>ongodb<span class="regexp">/bin/m</span>ongodb.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>开机自动启动mongodb</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">vi /etc/rc.d/rc.local </span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mongodb/bin/mongod --config /usr/<span class="built_in">local</span>/mongodb/bin/mongodb.conf</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">chmod +x /etc/rc.d/rc.local   <span class="comment"># 一定要执行这句不然无法开机启动</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启一下系统测试下能不能自启</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入mongodb的shell模式 </span></span><br><span class="line">/usr/<span class="keyword">local</span>/mongodb/bin/mongo <span class="comment">--port 27017</span></span><br><span class="line"><span class="comment">#查看数据库列表</span></span><br><span class="line">show dbs</span><br><span class="line"><span class="comment">#当前db版本</span></span><br><span class="line">db.<span class="property">version</span>();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="安装_nginx">安装 nginx</h1><h1 id="安装_PHP">安装 PHP</h1></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/24/base64/" itemprop="url">
                关于base64编码的原理和实现
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-12-24T09:57:20+08:00" content="2015-12-24">
            2015-12-24
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/javascript/" itemprop="url" rel="index">
                  <span itemprop="name">javascript</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/24/base64/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/24/base64/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="关于base64编码的原理和实现">关于base64编码的原理和实现</h1><blockquote>
<p>一句话解释：<code>Base64</code>是一种基于64个可打印字符来表示二进制数据的表示方法。</p>
</blockquote>
<p>用记事本打开 <code>exe</code>、<code>jpg</code>、<code>pdf</code> 这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。<code>Base64</code> 是一种最常见的二进制编码方法。</p>
<p>Base64的原理很简单，首先，准备一个包含 64 个字符的数组：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">[</span><span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="attribute">...</span> <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="attribute">...</span> <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="attribute">...</span> <span class="string">'+'</span>, <span class="string">'/'</span><span class="preprocessor">]</span><span class="markup"></span></span><br></pre></td></tr></table></figure></p>
<p>附 base64 索引表：<br><img src="/uploads/675542-20151220204555476-241320993.png" alt="base64 索引表" title="base64 索引表"></p>
<p>然后，对二进制数据进行处理，每 3 个字节一组（如果字节数不能被 3 整除，则用 0 补位），每个字节是 8 bits，一共是 3 x 8 = 24 bits，划为 4 组，每组正好 6 个 bits。将每组的 6 bits 转为十进制数字，这样我们得到 4 个数字作为索引（3-&gt;4，所以经过 base64 编码的图片会比原文件大 1/3，不过一般经过 gzip 压缩后跟原文件大小差不多），然后查表，获得相应的 4 个字符，就是编码后的字符串。</p>
<p>如果是字符串的 <code>base64</code> 编码，具体步骤为：</p>
<ol>
<li>获取字符串每个字符的 ASCII 码，如果字符数不能被 3 整除，则末尾补 0</li>
<li>将步骤 1 获取的 ASCII 码转为 8 位 二进制码</li>
<li>每 6 bits 为一组，并将 6 位二进制码转为十进制</li>
<li>对照上面的 base64 索引表，得到编码后的字符串</li>
</ol>
<p>需要注意的是：</p>
<ul>
<li>要求被编码字符是 8bit 的，所以须在 ASCII 编码范围内，\u0000-\u00ff，中文就不行</li>
<li>如果被编码字符长度不是 3 的倍数的时候，则都用 0 代替，对应的输出字符为 =，而不是查表所得的 A（所以通过 base64编码 的图片最后有时会有 1-2 个 =）</li>
</ul>
<p>举两个例子：<br>（1）字符长度能被 3 整除时，比如 <code>&#39;han&#39;</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">           h           a           n</span><br><span class="line">ASCII      <span class="number">104</span>          <span class="number">97</span>         <span class="number">110</span></span><br><span class="line"><span class="number">8</span>bit字节   <span class="number">01101000</span>    <span class="number">01100001</span>   <span class="number">01101110</span></span><br><span class="line"><span class="number">6</span>bit字节   <span class="number">011010</span>      <span class="number">000110</span>     <span class="number">000101</span>     <span class="number">101110</span></span><br><span class="line">十进制      <span class="number">26</span>          <span class="number">6</span>          <span class="number">5</span>          <span class="number">46</span></span><br><span class="line">对应编码    a           G          F          u</span><br></pre></td></tr></table></figure></p>
<p>（2）字符长度不能被 3 整除时，比如 <code>&#39;zichi&#39;</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">             z           i           c           h          i</span><br><span class="line">ASCII:      <span class="number">122</span>         <span class="number">105</span>          <span class="number">99</span>         <span class="number">104</span>        <span class="number">105</span></span><br><span class="line"><span class="number">8</span>bit字节:   <span class="number">01111010</span>    <span class="number">01101001</span>     <span class="number">01100011</span>   <span class="number">01101000</span>   <span class="number">01101001</span>   <span class="number">00000000</span>(补)</span><br><span class="line"><span class="number">6</span>bit字节:   <span class="number">011110</span>      <span class="number">100110</span>     <span class="number">100101</span>     <span class="number">100011</span>    <span class="number">011010</span>   <span class="number">000110</span>   <span class="number">100100</span>   <span class="number">000000</span></span><br><span class="line">十进制:     <span class="number">30</span>          <span class="number">38</span>         <span class="number">37</span>         <span class="number">35</span>        <span class="number">26</span>       <span class="number">6</span>        <span class="number">36</span>       异常</span><br><span class="line">对应编码:   e           m          l          j         a        G        k          =</span><br></pre></td></tr></table></figure></p>
<p>事实上，高级浏览器已经内置了 <code>atob （ASCII to Binary）</code>以及 <code>btoa （Binary to ASCII）</code>函数分别用来处理解码和编码 <code>base64</code> 字符串。<code>atob()</code> 函数能够解码通过 base-64 编码的字符串数据。相反地，<code>btoa()</code> 函数能够从二进制数据“字符串”创建一个 base-64 编码的 ASCII 字符串。（PS：特别要注意的是 btoa 是编码，atob 是解码 o(╯□╰)o）</p>
<p>不幸的是某些版本的 IE 浏览器并不支持 <code>atob()</code> 以及 <code>btoa()</code> 函数，好在理解了上述的编码步骤，一个 base64编码、转码器也就不难实现了。</p>
<p>Read More：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/Base64_encoding_and_decoding" target="_blank" rel="external">Base64的编码与解码</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="external">Base64 Wiki</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/btoa" target="_blank" rel="external">window.btoa</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/atob" target="_blank" rel="external">window.atob</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/22/javascript-06/" itemprop="url">
                JavaScript JQUERY
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-12-22T16:45:20+08:00" content="2015-12-22">
            2015-12-22
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/javascript/" itemprop="url" rel="index">
                  <span itemprop="name">javascript</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/22/javascript-06/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/22/javascript-06/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="jQuery">jQuery</h1><h2 id="jQuery版本">jQuery版本</h2><p>目前jQuery有1.x和2.x两个主要版本，区别在于2.x移除了对古老的IE 6、7、8的支持，因此2.x的代码更精简。选择哪个版本主要取决于你是否想支持IE 6~8。</p>
<h2 id="$符号">$符号</h2><p><code>$</code>是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line"><span class="built_in">window</span>.$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">$ === jQuery; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span>($); <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure></p>
<p><code>$</code>本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性。</p>
<blockquote>
<p>注意，你看到的<code>$</code>函数名可能不是<code>jQuery(selector, context)</code>，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码<code>$</code>函数可能变成<code>a(b, c)</code>。</p>
</blockquote>
<p>绝大多数时候，我们都直接用<code>$</code>（因为写起来更简单嘛）。但是，如果<code>$</code>这个变量不幸地被占用了，而且还不能改，那我们就只能让<code>jQuery</code>把<code>$</code>变量交出来，然后就只能使用<code>jQuery</code>这个变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">jQuery.noConflict();</span><br><span class="line">$; <span class="comment">// undefined</span></span><br><span class="line">jQuery; <span class="comment">// jQuery(selector, context)</span></span><br></pre></td></tr></table></figure></p>
<p>这种黑魔法的原理是<code>jQuery</code>在占用<code>$</code>之前，先在内部保存了原来的<code>$</code>,调用<code>jQuery.noConflict()</code>时会把原来保存的变量还原。</p>
<h2 id="选择器">选择器</h2><p>选择器是jQuery的核心。一个选择器写出来类似<code>$(&#39;#dom-id&#39;)</code>。<br>为什么jQuery要发明选择器？DOM操作中我们经常使用的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按ID查找：</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'dom-id'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按tag查找：</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagNames(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找&lt;p class="red"&gt;：</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.getElementsByTagNames(<span class="string">'p'</span>);</span><br><span class="line"><span class="comment">// 过滤出class="red":</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找&lt;table class="green"&gt;里面的所有&lt;tr&gt;：</span></span><br><span class="line"><span class="keyword">var</span> table = ...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;table.children; i++) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 过滤出&lt;tr&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些代码实在太繁琐了，并且，在层级关系中，例如，查找<code>&lt;table class=&quot;green&quot;&gt;</code>里面的所有<code>&lt;tr&gt;</code>，一层循环实际上是错的，因为<code>&lt;table&gt;</code>的标准写法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tr</span>&gt;</span>...<span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tr</span>&gt;</span>...<span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>很多时候，需要递归查找所有子节点。</p>
<p>jQuery的选择器就是帮助我们快速定位到一个或多个DOM节点。</p>
<h3 id="按ID查找">按ID查找</h3><p>如果某个DOM节点有id属性，利用jQuery查找如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找&lt;div id="abc"&gt;:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>注意</code>，<code>#abc</code>以<code>#</code>开头。返回的对象是jQuery对象。<br>什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。</p>
<p>以上面的查找为例，如果<code>id</code>为<code>abc</code>的<code>&lt;div&gt;</code>存在，返回的jQuery对象如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"abc"</span>&gt;</span>...<span class="tag">&lt;/<span class="title">div</span>&gt;</span>]</span><br></pre></td></tr></table></figure></p>
<p>如果id为<code>abc</code>的<code>&lt;div&gt;</code>不存在，返回的jQuery对象如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure></p>
<p>总之jQuery的选择器不会返回<code>undefined</code>或者<code>null</code>，这样的好处是你不必在下一行判断<code>if (div === undefined)</code>。<br>jQuery对象和DOM对象之间可以互相转化：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>); <span class="comment">// jQuery对象</span></span><br><span class="line"><span class="keyword">var</span> divDom = div.get(<span class="number">0</span>); <span class="comment">// 假设存在div，获取第1个DOM元素</span></span><br><span class="line"><span class="keyword">var</span> another = $(divDom); <span class="comment">// 重新把DOM包装为jQuery对象</span></span><br></pre></td></tr></table></figure></p>
<p>通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用<code>$(aDomObject)</code>把它变成jQuery对象，这样就可以方便地使用jQuery的API了。</p>
<h3 id="按tag查找">按tag查找</h3><p>按tag查找只需要写上tag名称就可以了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">'p'</span>); <span class="comment">// 返回所有&lt;p&gt;节点</span></span><br><span class="line">ps.length; <span class="comment">// 数一数页面有多少个&lt;p&gt;节点</span></span><br></pre></td></tr></table></figure></p>
<h3 id="按class查找">按class查找</h3><p>按class查找注意在class名称前加一个.：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'.red'</span>); <span class="comment">// 所有节点包含`class="red"`都将返回</span></span><br><span class="line"><span class="comment">// 例如:</span></span><br><span class="line"><span class="comment">// &lt;div class="red"&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;p class="green red"&gt;...&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>通常很多节点有多个class，我们可以查找同时包含red和green的节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'.red.green'</span>); <span class="comment">// 注意没有空格！</span></span><br><span class="line"><span class="comment">// 符合条件的节点：</span></span><br><span class="line"><span class="comment">// &lt;div class="red green"&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;div class="blue green red"&gt;...&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="按属性查找">按属性查找</h3><p>一个DOM节点除了id和class外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> email = $(<span class="string">'[name=email]'</span>); <span class="comment">// 找出&lt;??? name="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> passwordInput = $(<span class="string">'[type=password]'</span>); <span class="comment">// 找出&lt;??? type="password"&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'[items="A B"]'</span>); <span class="comment">// 找出&lt;??? items="A B"&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当属性的值包含空格等特殊字符时，需要用双引号括起来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'[name^=icon]'</span>); <span class="comment">// 找出所有name属性值以icon开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: name="icon-1", name="icon-2"</span></span><br><span class="line"><span class="keyword">var</span> names = $(<span class="string">'[name$=with]'</span>); <span class="comment">// 找出所有name属性值以with结尾的DOM</span></span><br><span class="line"><span class="comment">// 例如: name="startswith", name="endswith"</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'[class^="icon-"]'</span>); <span class="comment">// 找出所有class包含至少一个以`icon-`开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: class="icon-clock", class="abc icon-home"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="组合查找">组合查找</h3><p>组合查找就是把上述简单选择器组合起来使用。如果我们查找$(‘[name=email]’)，很可能把表单外的<div name="email">也找出来，但我们只希望查找<input>，就可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emailInput = $(<span class="string">'input[name=email]'</span>); <span class="comment">// 不会找出&lt;div name="email"&gt;</span></span><br></pre></td></tr></table></figure></div></p>
<p>同样的，根据tag和class来组合查找也很常见：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tr = $(<span class="string">'tr.red'</span>); <span class="comment">// 找出&lt;tr class="red ..."&gt;...&lt;/tr&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="多项选择器">多项选择器</h3><p>多项选择器就是把多个选择器用,组合起来一块选：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p,div'</span>); <span class="comment">// 把&lt;p&gt;和&lt;div&gt;都选出来</span></span><br><span class="line">$(<span class="string">'p.red,p.green'</span>); <span class="comment">// 把&lt;p class="red"&gt;和&lt;p class="green"&gt;都选出来</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。例如，<code>&lt;p class=&quot;red green&quot;&gt;</code>不会被上面的<code>$(&#39;p.red,p.green&#39;)</code>选择两次。</p>
</blockquote>
<h2 id="层级选择器">层级选择器</h2><p>除了基本的选择器外，jQuery的层级选择器更加灵活，也更强大。<br>因为DOM的结构就是层级结构，所以我们经常要根据层级关系进行选择。</p>
<h3 id="层级选择器（Descendant_Selector）">层级选择器（Descendant Selector）</h3><p>如果两个DOM元素具有层级关系，就可以用<code>$(&#39;ancestor descendant&#39;)</code>来选择，层级之间用空格隔开。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"testing"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"lang"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"lang-javascript"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"lang-python"</span>&gt;</span>Python<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"lang-lua"</span>&gt;</span>Lua<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>要选出JavaScript，可以用层级选择器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li.lang-javascript'</span>); <span class="comment">// [&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]</span></span><br><span class="line">$(<span class="string">'div.testing li.lang-javascript'</span>); <span class="comment">// [&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]</span></span><br></pre></td></tr></table></figure></p>
<p>因为<code>&lt;div&gt;</code>和<code>&lt;ul&gt;</code>都是<code>&lt;li&gt;</code>的祖先节点，所以上面两种方式都可以选出相应的<code>&lt;li&gt;</code>节点。<br>要选择所有的<li>节点，用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li'</span>);</span><br></pre></td></tr></table></figure></li></p>
<p>这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素。<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'form[name=upload] input'</span>);</span><br></pre></td></tr></table></figure></p>
<p>就把选择范围限定在<code>name</code>属性为<code>upload</code>的表单里。如果页面有很多表单，其他表单的<code>&lt;input&gt;</code>不会被选择。<br>多层选择也是允许的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'form.test p input'</span>); <span class="comment">// 在form表单选择被&lt;p&gt;包含的&lt;input&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="子选择器（Child_Selector）">子选择器（Child Selector）</h3><p>子选择器<code>$(&#39;parent&gt;child&#39;)</code>类似层级选择器，但是限定了层级关系必须是父子关系，就是<code>&lt;child&gt;</code>节点必须是<code>&lt;parent&gt;</code>节点的直属子节点。还是以上面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang&gt;li.lang-javascript'</span>); <span class="comment">// 可以选出[&lt;li class="lang-javascript"&gt;JavaScript&lt;/li&gt;]</span></span><br><span class="line">$(<span class="string">'div.testing&gt;li.lang-javascript'</span>); <span class="comment">// [], 无法选出，因为&lt;div&gt;和&lt;li&gt;不构成父子关系</span></span><br></pre></td></tr></table></figure></p>
<h3 id="过滤器（Filter）">过滤器（Filter）</h3><p>过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li'</span>); <span class="comment">// 选出JavaScript、Python和Lua 3个节点</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'ul.lang li:first-child'</span>); <span class="comment">// 仅选出JavaScript</span></span><br><span class="line">$(<span class="string">'ul.lang li:last-child'</span>); <span class="comment">// 仅选出Lua</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(2)'</span>); <span class="comment">// 选出第N个元素，N从1开始</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(even)'</span>); <span class="comment">// 选出序号为偶数的元素</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(odd)'</span>); <span class="comment">// 选出序号为奇数的元素</span></span><br></pre></td></tr></table></figure></p>
<h3 id="表单相关">表单相关</h3><p>针对表单元素，jQuery还有一组特殊的选择器：</p>
<ul>
<li><code>:input</code>：可以选择<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code>和<code>&lt;button&gt;</code>；</li>
<li><code>:file</code>：可以选择<code>&lt;input type=&quot;file&quot;&gt;</code>，和<code>input[type=file]</code>一样；</li>
<li><code>:checkbox</code>：可以选择复选框，和<code>input[type=checkbox]</code>一样；</li>
<li><code>:radio</code>：可以选择单选框，和<code>input[type=radio]</code>一样；</li>
<li><code>:focus</code>：可以选择当前输入焦点的元素，例如把光标放到一个<code>&lt;input&gt;</code>上，用<code>$(&#39;input:focus&#39;)</code>就可以选出；</li>
<li><code>:checked</code>：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$(&#39;input[type=radio]:checked&#39;)</code>；</li>
<li><code>:enabled</code>：可以选择可以正常输入的<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code><br>等，也就是没有灰掉的输入；</li>
<li><code>:disabled</code>：和<code>:enabled</code>正好相反，选择那些不能输入的。</li>
</ul>
<p>此外，jQuery还有很多有用的选择器，例如，选出可见的或隐藏的元素：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div:visible'</span>); <span class="comment">// 所有可见的div</span></span><br><span class="line">$(<span class="string">'div:hidden'</span>); <span class="comment">// 所有隐藏的div</span></span><br></pre></td></tr></table></figure></p>
<h2 id="查找和过滤">查找和过滤</h2><h3 id="查找">查找</h3><p>通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。<br>最常见的查找是在某个节点的所有子节点中查找，使用<code>find()</code>方法，它本身又接收一个任意的选择器。例如如下的HTML结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"lang"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"js dy"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"dy"</span>&gt;</span>Python<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">id</span>=<span class="value">"swift"</span>&gt;</span>Swift<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"dy"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">name</span>=<span class="value">"haskell"</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>用<code>find()</code>查找：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'ul.lang'</span>); <span class="comment">// 获得&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> dy = ul.find(<span class="string">'.dy'</span>); <span class="comment">// 获得JavaScript, Python, Scheme</span></span><br><span class="line"><span class="keyword">var</span> swf = ul.find(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> hsk = ul.find(<span class="string">'[name=haskell]'</span>); <span class="comment">// 获得Haskell</span></span><br></pre></td></tr></table></figure></p>
<p>如果要从当前节点开始向上查找，使用<code>parent()</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swf = $(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> parent = swf.parent(); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = swf.parent(<span class="string">'div.red'</span>); <span class="comment">// 从Swift的父节点开始向上查找，直到找到某个符合条件的节点并返回</span></span><br></pre></td></tr></table></figure></p>
<p>对于位于同一层级的节点，可以通过<code>next()</code>和<code>prev()</code>方法，例如：<br>当我们已经拿到Swift节点后：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swift = $(<span class="string">'#swift'</span>);</span><br><span class="line"></span><br><span class="line">swift.next(); <span class="comment">// Scheme</span></span><br><span class="line">swift.next(<span class="string">'[name=haskell]'</span>); <span class="comment">// Haskell，因为Haskell是后续第一个符合选择器条件的节点</span></span><br><span class="line"></span><br><span class="line">swift.prev(); <span class="comment">// Python</span></span><br><span class="line">swift.prev(<span class="string">'.js'</span>); <span class="comment">// JavaScript，因为JavaScript是往前第一个符合选择器条件的节点</span></span><br></pre></td></tr></table></figure></p>
<h3 id="过滤">过滤</h3><p>和函数式编程的map、filter类似，jQuery对象也有类似的方法。<br><code>filter()</code>方法可以过滤掉不符合选择器条件的节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> a = langs.filter(<span class="string">'.dy'</span>); <span class="comment">// 拿到JavaScript, Python, Scheme</span></span><br></pre></td></tr></table></figure></p>
<p>或者传入一个函数，要特别注意函数内部的this被绑定为DOM对象，不是jQuery对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line">langs.filter(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML.indexOf(<span class="string">'S'</span>) === <span class="number">0</span>; <span class="comment">// 返回S开头的节点</span></span><br><span class="line">&#125;); <span class="comment">// 拿到Swift, Scheme</span></span><br></pre></td></tr></table></figure></p>
<p><code>map()</code>方法把一个jQuery对象包含的若干DOM节点转化为其他对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> arr = langs.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML;</span><br><span class="line">&#125;).get(); <span class="comment">// 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']</span></span><br></pre></td></tr></table></figure></p>
<p>此外，一个jQuery对象如果包含了不止一个DOM节点，<code>first()</code>、<code>last()</code>和<code>slice()</code>方法可以返回一个新的jQuery对象，把不需要的DOM节点去掉：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> js = langs.first(); <span class="comment">// JavaScript，相当于$('ul.lang li:first-child')</span></span><br><span class="line"><span class="keyword">var</span> haskell = langs.last(); <span class="comment">// Haskell, 相当于$('ul.lang li:last-child')</span></span><br><span class="line"><span class="keyword">var</span> sub = langs.slice(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// Swift, Scheme, 参数和数组的slice()方法一致</span></span><br></pre></td></tr></table></figure></p>
<h2 id="操作DOM">操作DOM</h2><p>jQuery的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了jQuery对象，到底要干什么？</p>
<p>答案当然是操作对应的DOM节点啦！</p>
<h3 id="修改Text和HTML">修改Text和HTML</h3><p>jQuery对象的<code>text()</code>和<code>html()</code>方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"test-ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">name</span>=<span class="value">"book"</span>&gt;</span>Java &amp;amp; JavaScript<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>分别获取文本和HTML：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).text(); <span class="comment">// 'Java &amp; JavaScript'</span></span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).html(); <span class="comment">// 'Java &amp;amp; JavaScript'</span></span><br></pre></td></tr></table></figure></p>
<p>如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j1 = $(<span class="string">'#test-ul li.js'</span>);</span><br><span class="line"><span class="keyword">var</span> j2 = $(<span class="string">'#test-ul li[name=book]'</span>);</span><br><span class="line"></span><br><span class="line">j1.html(<span class="string">'&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;'</span>);</span><br><span class="line">j2.text(<span class="string">'JavaScript &amp; ECMAScript'</span>);</span><br></pre></td></tr></table></figure></p>
<p>一个jQuery对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上。在上面的例子中试试：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-ul li'</span>).text(<span class="string">'JS'</span>); <span class="comment">// 是不是两个节点都变成了JS？</span></span><br></pre></td></tr></table></figure></p>
<p>所以jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返回任何DOM节点，调用jQuery对象的方法仍然不会报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不存在id为not-exist的节点：</span></span><br><span class="line">$(<span class="string">'#not-exist'</span>).text(<span class="string">'Hello'</span>); <span class="comment">// 代码不报错，没有节点被设置为'Hello'</span></span><br></pre></td></tr></table></figure></p>
<p>这意味着jQuery帮你免去了许多if语句。</p>
<h3 id="修改CSS">修改CSS</h3><p>jQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"test-css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"lang dy"</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"lang"</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>Java<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"lang dy"</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"lang"</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"lang dy"</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>要高亮显示动态语言，调用jQuery对象的css(‘name’, ‘value’)方法，我们用一行语句实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-css li.dy&gt;span'</span>).css(<span class="string">'background-color'</span>, <span class="string">'#ffd351'</span>).css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行链式调用，非常方便。</p>
</blockquote>
<p>jQuery对象的<code>css()</code>方法可以这么用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.css(<span class="string">'color'</span>); <span class="comment">// '#000033', 获取CSS属性</span></span><br><span class="line">div.css(<span class="string">'color'</span>, <span class="string">'#336699'</span>); <span class="comment">// 设置CSS属性</span></span><br><span class="line">div.css(<span class="string">'color'</span>, <span class="string">''</span>); <span class="comment">// 清除CSS属性</span></span><br></pre></td></tr></table></figure></p>
<p>为了和JavaScript保持一致，CSS属性可以用<code>&#39;background-color&#39;</code>和<code>&#39;backgroundColor&#39;</code>两种格式。<br><code>css()</code>方法将作用于DOM节点的style属性，具有最高优先级。如果要修改class属性，可以用jQuery提供的下列方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.hasClass(<span class="string">'highlight'</span>); <span class="comment">// false， class是否包含highlight</span></span><br><span class="line">div.addClass(<span class="string">'highlight'</span>); <span class="comment">// 添加highlight这个class</span></span><br><span class="line">div.removeClass(<span class="string">'highlight'</span>); <span class="comment">// 删除highlight这个class</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修改DOM结构">修改DOM结构</h2><p>直接使用浏览器提供的API对DOM结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。</p>
<p>有了jQuery，我们就专注于操作jQuery对象本身，底层的DOM操作由jQuery完成就可以了，这样一来，修改DOM也大大简化了。</p>
<h3 id="添加DOM">添加DOM</h3><p>要添加新的DOM节点，除了通过jQuery的html()这种暴力方法外，还可以用<code>append()</code>方法，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test-div"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>Python<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>Swift<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如何向列表新增一个语言：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'#test-div&gt;ul'</span>);</span><br><span class="line">ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'</span>);</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p>
<p>除了接受字符串，<code>append()</code>还可以传入原始的DOM对象，jQuery对象和函数对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建DOM对象:</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">ps.innerHTML = <span class="string">'&lt;span&gt;Pascal&lt;/span&gt;'</span>;</span><br><span class="line"><span class="comment">// 添加DOM对象:</span></span><br><span class="line">ul.append(ps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加jQuery对象:</span></span><br><span class="line">ul.append($(<span class="string">'#scheme'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加函数对象:</span></span><br><span class="line">ul.append(<span class="function"><span class="keyword">function</span> (<span class="params">index, html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;li&gt;&lt;span&gt;Language - '</span> + index + <span class="string">'&lt;/span&gt;&lt;/li&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>传入函数时，要求返回一个字符串、DOM对象或者jQuery对象。因为jQuery的<code>append()</code>可能作用于一组DOM节点，只有传入函数才能针对每个DOM生成不同的子节点。</p>
<p><code>append()</code>把DOM添加到最后，<code>prepend()</code>则把DOM添加到最前。<br>另外注意，如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，也就是说，用<code>append()</code>，你可以移动一个DOM节点。<br>如果要把新节点插入到指定位置，例如，JavaScript和Python之间，那么，可以先定位到JavaScript，然后用<code>after()</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = $(<span class="string">'#test-div&gt;ul&gt;li:first-child'</span>);</span><br><span class="line">js.after(<span class="string">'&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure></p>
<p>也就是说，同级节点可以用<code>after()</code>或者<code>before()</code>方法。</p>
<h3 id="删除节点">删除节点</h3><p>要删除DOM节点，拿到jQuery对象后直接调用<code>remove()</code>方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> li = $(<span class="string">'#test-div&gt;ul&gt;li'</span>);</span><br><span class="line">li.remove(); <span class="comment">// 所有&lt;li&gt;全被删除</span></span><br></pre></td></tr></table></figure></p>
<h2 id="事件">事件</h2><p>因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。</p>
<p>浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。</p>
<p>由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。</p>
<p>举个例子，假设要在用户点击了超链接时弹出提示框，我们用jQuery这样绑定一个click事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML:</span><br><span class="line"> *</span><br><span class="line"> * &lt;a id="test-link" href="#0"&gt;点我试试&lt;/a&gt;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取超链接的jQuery对象:</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'#test-link'</span>);</span><br><span class="line">a.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>on</code>方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。<br>另一种更简化的写法是直接调用<code>click()</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>两者完全等价。我们通常用后面的写法。</p>
<p>jQuery能够绑定的事件主要包括：</p>
<h3 id="鼠标事件">鼠标事件</h3><ul>
<li><code>click</code>: 鼠标单击时触发；</li>
<li><code>dblclick</code>：鼠标双击时触发；</li>
<li><code>mouseenter</code>：鼠标进入时触发；</li>
<li><code>mouseleave</code>：鼠标移出时触发；</li>
<li><code>mousemove</code>：鼠标在DOM内部移动时触发；</li>
<li><code>hover</code>：鼠标进入和退出时触发两个函数，相当于<code>mouseenter</code>加上<code>mouseleave</code>。</li>
</ul>
<h3 id="键盘事件">键盘事件</h3><p>键盘事件仅作用在当前焦点的DOM上，通常是<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>。</p>
<ul>
<li><code>keydown</code>：键盘按下时触发；</li>
<li><code>keyup</code>：键盘松开时触发；</li>
<li><code>keypress</code>：按一次键后触发。</li>
</ul>
<h3 id="其他事件">其他事件</h3><ul>
<li><code>focus</code>：当DOM获得焦点时触发；</li>
<li><code>blur</code>：当DOM失去焦点时触发；</li>
<li><code>change</code>：当<code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>或<code>&lt;textarea&gt;</code>的内容改变时触发；</li>
<li><code>submit</code>：当<code>&lt;form&gt;</code>提交时触发；</li>
<li><code>ready</code>：当页面被载入并且DOM树完成初始化后触发。</li>
</ul>
<p>其中，<code>ready</code>仅作用于<code>document</code>对象。由于<code>ready</code>事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。<br>假设我们想给一个<code>&lt;form&gt;</code>表单绑定<code>submi</code>t事件，下面的代码没有预期的效果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="undefined"></span><br><span class="line">        // 代码有误:</span><br><span class="line">        $('#testForm).on('submit', function () &#123;</span><br><span class="line">            alert('submit!');</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">form</span> <span class="attribute">id</span>=<span class="value">"testForm"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>因为JavaScript在此执行的时候，<code>&lt;form&gt;</code>尚未载入浏览器，所以<code>$(&#39;#testForm)</code>返回<code>[]</code>，并没有绑定事件到任何DOM上。</p>
<p>所以我们自己的初始化代码必须放到<code>document</code>对象的<code>ready</code>事件中，保证DOM已完成初始化：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="undefined"></span><br><span class="line">        $(document).on('ready', function () &#123;</span><br><span class="line">            $('#testForm).on('submit', function () &#123;</span><br><span class="line">                alert('submit!');</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">form</span> <span class="attribute">id</span>=<span class="value">"testForm"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。</p>
<p>由于<code>ready</code>事件使用非常普遍，所以可以这样简化：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    // on('submit', function)也可以简化:</span><br><span class="line">    $('#testForm).submit(function () &#123;</span><br><span class="line">        alert('submit!');</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>甚至还可以再简化为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// init...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的这种写法最为常见。如果你遇到<code>$(function () {...})</code>的形式，牢记这是<code>document</code>对象的<code>ready</code>事件处理函数。</p>
<p>完全可以反复绑定事件处理函数，它们会依次执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'init A...'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'init B...'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'init C...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="事件参数">事件参数</h3><p>有些事件，如<code>mousemove</code>和<code>keypress</code>，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testMouseMoveDiv'</span>).mousemove(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#testMouseMoveSpan'</span>).text(<span class="string">'pageX = '</span> + e.pageX + <span class="string">', pageY = '</span> + e.pageY);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="取消绑定">取消绑定</h3><p>一个已被绑定的事件可以解除绑定，通过<code>off(&#39;click&#39;, function)</code>实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.click(hello); <span class="comment">// 绑定事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟后解除绑定:</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a.off(<span class="string">'click'</span>, hello);</span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure></p>
<p>需要特别注意的是，下面这种写法是无效的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定事件:</span></span><br><span class="line">a.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除绑定:</span></span><br><span class="line">a.off(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这是因为两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象，<code>off(&#39;click&#39;, function () {...})</code>无法移除已绑定的第一个匿名函数。</p>
<p>为了实现移除效果，可以使用<code>off(&#39;click&#39;)</code>一次性移除已绑定的<code>click</code>事件的所有处理函数。</p>
<p>同理，无参数调用<code>off()</code>一次性移除已绑定的所有类型的事件处理函数。</p>
<h3 id="事件触发条件">事件触发条件</h3><p>一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.change(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'changed...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>当用户在文本框中输入时，就会触发<code>change</code>事件。但是，如果用JavaScript代码去改动文本框的值，将不会触发<code>change</code>事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.val(<span class="string">'change it!'</span>); <span class="comment">// 无法触发change事件</span></span><br></pre></td></tr></table></figure></p>
<p>有些时候，我们希望用代码触发<code>change</code>事件，可以直接调用无参数的<code>change()</code>方法来触发该事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.val(<span class="string">'change it!'</span>);</span><br><span class="line">input.change(); <span class="comment">// 触发change事件</span></span><br></pre></td></tr></table></figure></p>
<p><code>input.change()</code>相当于<code>input.trigger(&#39;change&#39;)</code>，它是<code>trigger()</code>方法的简写。</p>
<h3 id="浏览器安全限制">浏览器安全限制</h3><p>在浏览器中，有些JavaScript代码只有在用户触发下才能执行，例如，<code>window.open()</code>函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法弹出新窗口，将被浏览器屏蔽:</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">'/'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这些“敏感代码”只能由用户操作来触发：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button1 = $(<span class="string">'#testPopupButton1'</span>);</span><br><span class="line"><span class="keyword">var</span> button2 = $(<span class="string">'#testPopupButton2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">popupTestWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">'/'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button1.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    popupTestWindow();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">button2.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不立刻执行popupTestWindow()，100毫秒后执行:</span></span><br><span class="line">    setTimeout(popupTestWindow, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>当用户点击<code>button1</code>时，<code>click</code>事件被触发，由于<code>popupTestWindow()</code>在<code>click</code>事件处理函数内执行，这是浏览器允许的，而<code>button2</code>的<code>click</code>事件并未立刻执行<code>popupTestWindow()</code>，延迟执行的<code>popupTestWindow()</code>将被浏览器拦截。</p>
<h2 id="动画">动画</h2><p>用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。</p>
<p>但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。</p>
<p>使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！</p>
<h3 id="show_/_hide">show / hide</h3><p>直接以无参数形式调用<code>show()</code>和<code>hide()</code>，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-show-hide'</span>);</span><br><span class="line">div.hide(<span class="number">3000</span>); <span class="comment">// 在3秒钟内逐渐消失</span></span><br></pre></td></tr></table></figure></p>
<p>时间以毫秒为单位，但也可以是<code>&#39;slow&#39;</code>，<code>&#39;fast&#39;</code>这些字符串：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-show-hide'</span>);</span><br><span class="line">div.show(<span class="string">'slow'</span>); <span class="comment">// 在0.6秒钟内逐渐显示</span></span><br></pre></td></tr></table></figure></p>
<p><code>toggle()</code>方法则根据当前状态决定是<code>show()</code>还是<code>hide()</code>。</p>
<h3 id="slideUp_/_slideDown">slideUp / slideDown</h3><p><code>show()</code>和<code>hide()</code>是从左上角逐渐展开或收缩的，而<code>slideUp()</code>和<code>slideDown()</code>则是在垂直方向逐渐展开或收缩的。<br><code>slideUp()</code>把一个可见的DOM元素收起来，效果跟拉上窗帘似的，<code>slideDown()</code>相反，而<code>slideToggle()</code>则根据元素是否可见来决定下一步动作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-slide'</span>);</span><br><span class="line">div.slideUp(<span class="number">3000</span>); <span class="comment">// 在3秒钟内逐渐向上消失</span></span><br></pre></td></tr></table></figure></p>
<h3 id="fadeIn_/_fadeOut">fadeIn / fadeOut</h3><p><code>fadeIn()</code>和<code>fadeOut()</code>的动画效果是淡入淡出，也就是通过不断设置DOM元素的<code>opacity</code>属性来实现，而<code>fadeToggle()</code>则根据元素是否可见来决定下一步动作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-fade'</span>);</span><br><span class="line">div.fadeOut(<span class="string">'slow'</span>); <span class="comment">// 在0.6秒内淡出</span></span><br></pre></td></tr></table></figure></p>
<h3 id="自定义动画">自定义动画</h3><p>如果上述动画效果还不能满足你的要求，那就祭出最后大招：<code>animate()</code>，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animate'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>); <span class="comment">// 在3秒钟内CSS过渡到设定值</span></span><br></pre></td></tr></table></figure></p>
<p><code>animate()</code>还可以再传入一个函数，当动画结束时，该函数将被调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animate'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画已结束'</span>);</span><br><span class="line">    <span class="comment">// 恢复至初始状态:</span></span><br><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'opacity'</span>, <span class="string">'1.0'</span>).css(<span class="string">'width'</span>, <span class="string">'128px'</span>).css(<span class="string">'height'</span>, <span class="string">'128px'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>实际上这个回调函数参数对于基本动画也是适用的。</p>
<h3 id="串行动画">串行动画</h3><p>jQuery的动画效果还可以串行执行，通过<code>delay()</code>方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animates'</span>);</span><br><span class="line"><span class="comment">// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小</span></span><br><span class="line">div.slideDown(<span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'256px'</span>,</span><br><span class="line">       height: <span class="string">'256px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'128px'</span>,</span><br><span class="line">       height: <span class="string">'128px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p>
<p>因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。</p>
<h3 id="为什么有的动画没有效果">为什么有的动画没有效果</h3><p>有的动画如<code>slideUp()</code>根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如<code>height</code>从<code>100px</code>逐渐变为<code>0</code>。但是很多不是<code>block</code>性质的DOM元素，对它们设置<code>height</code>根本就不起作用，所以动画也就没有效果。<br>此外，jQuery也没有实现对<code>background-color</code>的动画效果，用<code>animate()</code>设置<code>background-color</code>也没有效果。这种情况下可以使用CSS3的<code>transition</code>实现动画效果。</p>
<h2 id="AJAX">AJAX</h2><p>用jQuery的相关对象来处理AJAX，不但不需要考虑浏览器问题，代码也能大大简化。</p>
<p>jQuery在全局对象jQuery（也就是$）绑定了<code>ajax()</code>函数，可以处理AJAX请求。<code>ajax(url, settings)</code>函数需要接收一个<code>URL</code>和一个可选的<code>settings</code>对象，常用的选项如下：</p>
<ul>
<li><code>async</code>：是否异步执行AJAX请求，默认为<code>true</code>，千万不要指定为<code>false</code>；</li>
<li><code>method</code>：发送的Method，缺省为<code>&#39;GET&#39;</code>，可指定为<code>&#39;POST&#39;</code>、<code>&#39;PUT&#39;</code>等；</li>
<li><code>contentType</code>：发送POST请求的格式，默认值为<code>&#39;application/x-www-form-urlencoded; charset=UTF-8&#39;</code>，也可以指定为<code>text/plain</code>、<code>application/json</code>；</li>
<li><code>data</code>：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；</li>
<li><code>headers</code>：发送的额外的HTTP头，必须是一个object；</li>
<li><code>dataType</code>：接收的数据格式，可以指定为<code>&#39;html&#39;</code>、<code>&#39;xml&#39;</code>、<code>&#39;json&#39;</code>、<code>&#39;text&#39;</code>等，缺省情况下根据响应的Content-Type猜测。</li>
</ul>
<p>下面的例子发送一个GET请求，并返回一个JSON格式的数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'/api/categories'</span>, &#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 请求已经发送了</span></span><br></pre></td></tr></table></figure></p>
<p>不过，如何用回调函数处理返回的数据和出错时的响应呢？</p>
<p>jQuery的jqXHR对象类似一个Promise对象，我们可以用链式写法来处理各种回调：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxLog</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> txt = $(<span class="string">'#test-response-text'</span>);</span><br><span class="line">    txt.val(txt.val() + <span class="string">'\n'</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'/api/categories'</span>, &#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'成功, 收到的数据: '</span> + <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;).fail(<span class="function"><span class="keyword">function</span> (<span class="params">xhr, status</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'失败: '</span> + xhr.status + <span class="string">', 原因: '</span> + status);</span><br><span class="line">&#125;).always(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'请求完成: 无论成功或失败都会调用'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="get">get</h3><p>对常用的AJAX操作，jQuery提供了一些辅助方法。由于GET请求最常见，所以jQuery提供了<code>get()</code>方法，可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.get(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/path/to/resource?name=Bob%20Lee&amp;<span class="operator"><span class="keyword">check</span>=<span class="number">1</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line">这样我们就不用关心如何用URL编码并构造一个query string了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### post</span><br><span class="line">`</span>post()<span class="string">`和`</span><span class="keyword">get</span>()<span class="string">`类似，但是传入的第二个参数默认被序列化为`</span>application/x-www-<span class="keyword">form</span>-urlencoded<span class="string">`：</span><br><span class="line">`</span><span class="string">``</span> js </span><br><span class="line"><span class="keyword">var</span> jqxhr = $.post(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    <span class="keyword">name</span>: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    <span class="keyword">check</span>: <span class="number">1</span></span><br><span class="line">&#125;);</span></span><br></pre></td></tr></table></figure></p>
<p>实际构造的数据<code>name=Bob%20Lee&amp;check=1</code>作为POST的body被发送。</p>
<h3 id="getJSON">getJSON</h3><p>由于JSON用得越来越普遍，所以jQuery也提供了<code>getJSON()</code>方法来快速通过GET获取一个JSON对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.getJSON(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// data已经被解析为JSON对象了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="安全限制">安全限制</h3><p>jQuery的AJAX完全封装的是JavaScript的AJAX操作，所以它的安全限制和前面讲的用JavaScript写AJAX完全一样。</p>
<p>如果需要使用JSONP，可以在<code>ajax()</code>中设置<code>jsonp: &#39;callback&#39;</code>，让jQuery实现JSONP跨域加载数据。</p>
<h2 id="扩展">扩展</h2><p>当我们使用jQuery对象的方法时，由于jQuery对象可以操作一组DOM，而且支持链式操作，所以用起来非常方便。</p>
<p>但是jQuery内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些DOM元素，用jQuery可以这么实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'span.hl'</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'#fffceb'</span>).css(<span class="string">'color'</span>, <span class="string">'#d85030'</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'p a.hl'</span>).css(<span class="string">'backgroundColor'</span>, <span class="string">'#fffceb'</span>).css(<span class="string">'color'</span>, <span class="string">'#d85030'</span>);</span><br></pre></td></tr></table></figure></p>
<p>总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个highlight()方法？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'span.hl'</span>).highlight();</span><br><span class="line"></span><br><span class="line">$(<span class="string">'p a.hl'</span>).highlight();</span><br></pre></td></tr></table></figure></p>
<p>答案是肯定的。我们可以扩展jQuery来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写jQuery插件。</p>
<h3 id="编写jQuery插件">编写jQuery插件</h3><p>给jQuery对象绑定一个新方法是通过扩展<code>$.fn</code>对象实现的。让我们来编写第一个扩展——<code>highlight1()</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this已绑定为当前jQuery对象:</span></span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, <span class="string">'#fffceb'</span>).css(<span class="string">'color'</span>, <span class="string">'#d85030'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到函数内部的<code>this</code>在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法。</p>
<p>对于如下的HTML结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test-highlight1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>什么是<span class="tag">&lt;<span class="title">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="title">span</span>&gt;</span>是目前最流行的<span class="tag">&lt;<span class="title">span</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="title">span</span>&gt;</span>库。<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-highlight1 span'</span>).highlight1();</span><br></pre></td></tr></table></figure>
<p>为什么最后要<code>return this;</code>？因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'span.hl'</span>).highlight1().slideDown();</span><br></pre></td></tr></table></figure></p>
<p>不然，用户调用的时候，就不得不把上面的代码拆成两行。</p>
<p>但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？</p>
<p>我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的<code>highlight2()</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight2 = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 要考虑到各种情况:</span></span><br><span class="line">    <span class="comment">// options为undefined</span></span><br><span class="line">    <span class="comment">// options只有部分key</span></span><br><span class="line">    <span class="keyword">var</span> bgcolor = options &amp;&amp; options.backgroundColor || <span class="string">'#fffceb'</span>;</span><br><span class="line">    <span class="keyword">var</span> color = options &amp;&amp; options.color || <span class="string">'#d85030'</span>;</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, bgcolor).css(<span class="string">'color'</span>, color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用代码进行调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#test-highlight2 span'</span>).highlight2(&#123;</span><br><span class="line">    backgroundColor: <span class="string">'#00a8e6'</span>,</span><br><span class="line">    color: <span class="string">'#ffffff'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对于默认值的处理，我们用了一个简单的<code>&amp;&amp;</code>和<code>||</code>短路操作符，总能得到一个有效的值。</p>
<p>另一种方法是使用jQuery提供的辅助方法<code>$.extend(target, obj1, obj2, ...)</code>，它把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把默认值和用户传入的options合并到对象&#123;&#125;中并返回:</span></span><br><span class="line"><span class="keyword">var</span> opts = $.extend(&#123;&#125;, &#123;</span><br><span class="line">    backgroundColor: <span class="string">'#00a8e6'</span>,</span><br><span class="line">    color: <span class="string">'#ffffff'</span></span><br><span class="line">&#125;, options);</span><br></pre></td></tr></table></figure></p>
<p>紧接着用户对<code>highlight2()</code>提出了意见：每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的<code>highlight2()</code>？<br>也就是说，我们设定的默认值应该能允许用户修改。</p>
<p>那默认值放哪比较合适？放全局变量肯定不合适，最佳地点是<code>$.fn.highlight2</code>这个函数对象本身。<br>于是最终版的<code>highlight()</code>终于诞生了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 合并默认值和用户设定值:</span></span><br><span class="line">    <span class="keyword">var</span> opts = $.extend(&#123;&#125;, $.fn.highlight.defaults, options);</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, opts.backgroundColor).css(<span class="string">'color'</span>, opts.color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定默认值:</span></span><br><span class="line">$.fn.highlight.defaults = &#123;</span><br><span class="line">    color: <span class="string">'#d85030'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'#fff8de'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用户使用时，只需一次性设定默认值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight.defaults.color = <span class="string">'#fff'</span>;</span><br><span class="line">$.fn.highlight.defaults.backgroundColor = <span class="string">'#000'</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以非常简单地调用<code>highlight()</code>了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight.defaults.color = <span class="string">'#659f13'</span>;</span><br><span class="line">$.fn.highlight.defaults.backgroundColor = <span class="string">'#f2fae3'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#test-highlight p:first-child span'</span>).highlight();</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#test-highlight p:last-child span'</span>).highlight(&#123;</span><br><span class="line">    color: <span class="string">'#dd1144'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>最终，我们得出编写一个jQuery插件的原则：</p>
<ol>
<li>给<code>$.fn</code>绑定函数，实现插件的代码逻辑；</li>
<li>插件函数最后要<code>return this;</code>以支持链式调用；</li>
<li>插件函数要有默认值，绑定在<code>$.fn.&lt;pluginName&gt;.defaults</code>上；</li>
<li>用户在调用时可传入设定值以便覆盖默认值。</li>
</ol>
<h3 id="针对特定元素的扩展">针对特定元素的扩展</h3><p>我们知道jQuery对象的有些方法只能作用在特定DOM元素上，比如<code>submit()</code>方法只能针对form。如果我们编写的扩展只能针对某些类型的DOM元素，应该怎么写？</p>
<p>还记得jQuery的选择器支持<code>filter()</code>方法来过滤吗？我们可以借助这个方法来实现针对特定元素的扩展。</p>
<p>举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做？</p>
<p>先写出用户调用的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#main a'</span>).external();</span><br></pre></td></tr></table></figure></p>
<p>然后按照上面的方法编写一个<code>external</code>扩展：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.fn.external = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return返回的each()返回结果，支持链式调用:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="string">'a'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注意: each()内部的回调函数的this绑定为DOM本身!</span></span><br><span class="line">        <span class="keyword">var</span> a = $(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">var</span> url = a.attr(<span class="string">'href'</span>);</span><br><span class="line">        <span class="keyword">if</span> (url &amp;&amp; (url.indexOf(<span class="string">'http://'</span>)===<span class="number">0</span> || url.indexOf(<span class="string">'https://'</span>)===<span class="number">0</span>)) &#123;</span><br><span class="line">            a.attr(<span class="string">'href'</span>, <span class="string">'#0'</span>)</span><br><span class="line">             .removeAttr(<span class="string">'target'</span>)</span><br><span class="line">             .append(<span class="string">' &lt;i class="uk-icon-external-link"&gt;&lt;/i&gt;'</span>)</span><br><span class="line">             .click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(confirm(<span class="string">'你确定要前往'</span> + url + <span class="string">'？'</span>)) &#123;</span><br><span class="line">                    <span class="built_in">window</span>.open(url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>扩展jQuery对象的功能十分简单，但是我们要遵循jQuery的原则，编写的扩展方法能支持链式调用、具备默认值和过滤特定元素，使得扩展方法看上去和jQuery本身的方法没有什么区别。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/uploads/avatar.jpg" alt="Johnson Zhang" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Johnson Zhang</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">48</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">43</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hpze2000" target="_blank">github</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Johnson Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"hpze2000"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
